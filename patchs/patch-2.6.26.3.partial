diff -uNr linux.vanilla/arch/x86/Kconfig linux.patch/arch/x86/Kconfig
--- linux.vanilla/arch/x86/Kconfig	2008-09-27 17:25:59.000000000 +1000
+++ linux.patch/arch/x86/Kconfig	2008-11-03 19:55:51.000000000 +1100
@@ -1729,3 +1729,5 @@
 source "arch/x86/kvm/Kconfig"
 
 source "lib/Kconfig"
+
+source "lemona/Kconfig"
diff -uNr linux.vanilla/arch/x86/mm/fault.c linux.patch/arch/x86/mm/fault.c
--- linux.vanilla/arch/x86/mm/fault.c	2008-09-27 17:25:59.000000000 +1000
+++ linux.patch/arch/x86/mm/fault.c	2008-11-03 19:55:51.000000000 +1100
@@ -723,6 +723,8 @@
 good_area:
 	si_code = SEGV_ACCERR;
 	write = 0;
+	/* LEMONA: if we are responsible for this fault,
+	   up_read(mm->mmap_sem) and return */
 	switch (error_code & (PF_PROT|PF_WRITE)) {
 	default:	/* 3: write, present */
 		/* fall through */
@@ -770,6 +772,7 @@
 	}
 #endif
 	up_read(&mm->mmap_sem);
+	/* LEMONA: if this was the first page_fault, log read data */
 	return;
 
 /*
diff -uNr linux.vanilla/fs/file_table.c linux.patch/fs/file_table.c
--- linux.vanilla/fs/file_table.c	2008-09-27 17:26:10.000000000 +1000
+++ linux.patch/fs/file_table.c	2008-11-03 19:55:43.000000000 +1100
@@ -337,6 +337,7 @@
 
 	return file;
 }
+EXPORT_SYMBOL(fget_light);
 
 
 void put_filp(struct file *file)
diff -uNr linux.vanilla/fs/open.c linux.patch/fs/open.c
--- linux.vanilla/fs/open.c	2008-09-27 17:26:11.000000000 +1000
+++ linux.patch/fs/open.c	2008-11-03 19:55:43.000000000 +1100
@@ -30,6 +30,8 @@
 #include <linux/audit.h>
 #include <linux/falloc.h>
 
+#include "../lemona/lemona_patch.h"
+
 int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	int retval = -ENODEV;
@@ -1110,7 +1112,44 @@
 	if (force_o_largefile())
 		flags |= O_LARGEFILE;
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_open, true, 3, 0, filename, &flags, &mode);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		if (_lemona_log == NULL)
+		  _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_open, true, 3, 0, filename, &flags, &mode);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
+
 	ret = do_sys_open(AT_FDCWD, filename, flags, mode);
+
+	/*
+	 * This should always be before asmlinkage_protect!
+	 *
+	 * We pass ret twice:
+	 *  - The first time to get the return value.
+	 *  - The second time to get the resoled filename (if fd >= 0)
+	 *
+	 */
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_open, false, 1, 1, &ret, &ret);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		if (_lemona_log == NULL)
+		  _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_open, false, 1, 1, &ret, &ret);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
+
 	/* avoid REGPARM breakage on x86: */
 	asmlinkage_protect(3, ret, filename, flags, mode);
 	return ret;
@@ -1124,7 +1163,36 @@
 	if (force_o_largefile())
 		flags |= O_LARGEFILE;
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_openat, true, 4, 0, &dfd, filename, &flags, &mode);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		if (_lemona_log == NULL)
+		  _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_openat, true, 4, 0, &dfd, filename, &flags, &mode);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
+
 	ret = do_sys_open(dfd, filename, flags, mode);
+
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_openat, false, 1, 1, &ret, &ret);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		if (_lemona_log == NULL)
+		  _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_openat, false, 1, 1, &ret, &ret);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
+
 	/* avoid REGPARM breakage on x86: */
 	asmlinkage_protect(4, ret, dfd, filename, flags, mode);
 	return ret;
@@ -1177,7 +1245,21 @@
 	struct file * filp;
 	struct files_struct *files = current->files;
 	struct fdtable *fdt;
-	int retval;
+	int retval = -EBADF;
+
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_close, true, 1, 0, &fd);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		if (_lemona_log == NULL)
+		  _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_close, true, 1, 0, &fd);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 
 	spin_lock(&files->file_lock);
 	fdt = files_fdtable(files);
@@ -1199,11 +1281,25 @@
 		     retval == -ERESTART_RESTARTBLOCK))
 		retval = -EINTR;
 
-	return retval;
+	goto out;
 
 out_unlock:
 	spin_unlock(&files->file_lock);
-	return -EBADF;
+out:
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_close, false, 1, 0, &retval);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		if (_lemona_log == NULL)
+		  _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_close, false, 1, 0, &retval);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
+	return retval;
 }
 
 EXPORT_SYMBOL(sys_close);
diff -uNr linux.vanilla/fs/read_write.c linux.patch/fs/read_write.c
--- linux.vanilla/fs/read_write.c	2008-09-27 17:26:11.000000000 +1000
+++ linux.patch/fs/read_write.c	2008-11-03 19:55:43.000000000 +1100
@@ -21,6 +21,9 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+#define LEMONA_READ
+#include "../lemona/lemona_patch.h"
+
 const struct file_operations generic_ro_fops = {
 	.llseek		= generic_file_llseek,
 	.read		= do_sync_read,
@@ -133,9 +136,27 @@
 	off_t retval;
 	struct file * file;
 	int fput_needed;
+#if defined(LEMONA)
+	bool lemona_file = false;
+#endif
 
 	retval = -EBADF;
 	file = fget_light(fd, &fput_needed);
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_lseek, true, 3, 0, &fd, &offset, &origin);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+		  lemona_get_fn(&_lemona_log, &_lemona_relay_is_ours);
+	    if (file == NULL
+			|| (lemona_file = _lemona_relay_is_ours(file->f_dentry)))
+		  _lemona_log(__NR_lseek, true, 3, 0, &fd, &offset, &origin);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	if (!file)
 		goto bad;
 
@@ -148,6 +169,19 @@
 	}
 	fput_light(file, fput_needed);
 bad:
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  lemona_log(__NR_lseek, false, 1, 0, &retval);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR_lseek, false, 1, 0, &retval);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	return retval;
 }
 
@@ -160,9 +194,29 @@
 	struct file * file;
 	loff_t offset;
 	int fput_needed;
+#if defined(LEMONA)
+	bool lemona_file = false;
+#endif
 
 	retval = -EBADF;
 	file = fget_light(fd, &fput_needed);
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR__llseek, true, 4, 0,
+				 &fd, &offset_high, &offset_low, &origin);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+		  lemona_get_fn(&_lemona_log, &_lemona_relay_is_ours);
+	    if (file == NULL
+			|| (lemona_file = _lemona_relay_is_ours(file->f_dentry)))
+		  _lemona_log(__NR__llseek, true, 4, 0,
+					  &fd, &offset_high, &offset_low, &origin);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	if (!file)
 		goto bad;
 
@@ -182,6 +236,20 @@
 out_putf:
 	fput_light(file, fput_needed);
 bad:
+	offset = retval == 0 ? offset : retval; /* for LEMONA */
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  lemona_log(__NR__llseek, false, 1, 0, &offset);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR__llseek, false, 1, 0, &offset);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	return retval;
 }
 #endif
@@ -355,15 +423,49 @@
 	struct file *file;
 	ssize_t ret = -EBADF;
 	int fput_needed;
+#if defined(LEMONA)
+	bool lemona_file = false;
+#endif
 
 	file = fget_light(fd, &fput_needed);
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0
+	    && (file == NULL
+			|| (lemona_file = lemona_relay_is_ours(file->f_dentry))))
+	  lemona_log(__NR_read, true, 2, 0, &fd, &count);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+	      lemona_get_fn(&_lemona_log, &_lemona_relay_is_ours);
+	    if (file == NULL
+			|| (lemona_file = _lemona_relay_is_ours(file->f_dentry)))
+		  _lemona_log(__NR_read, true, 2, 0, &fd, &count);
+	  }
+	else
+	  _lemona_log			= NULL;
+#endif
 	if (file) {
 		loff_t pos = file_pos_read(file);
 		ret = vfs_read(file, buf, count, &pos);
 		file_pos_write(file, pos);
 		fput_light(file, fput_needed);
+
 	}
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  lemona_log(__NR_read, false, 2, 0, buf, &ret);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR_read, false, 2, 0, buf, &ret);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	return ret;
 }
 
@@ -373,6 +475,20 @@
 	ssize_t ret = -EBADF;
 	int fput_needed;
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_write, true, 3, 0, &fd, buf, &count);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_write, true, 3, 0, &fd, buf, &count);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
+
 	file = fget_light(fd, &fput_needed);
 	if (file) {
 		loff_t pos = file_pos_read(file);
@@ -381,6 +497,19 @@
 		fput_light(file, fput_needed);
 	}
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_write, false, 1, 0, &ret);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR_write, false, 1, 0, &ret);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	return ret;
 }
 
@@ -390,18 +519,52 @@
 	struct file *file;
 	ssize_t ret = -EBADF;
 	int fput_needed;
+#if defined(LEMONA)
+	bool lemona_file = false;
+#endif
 
-	if (pos < 0)
-		return -EINVAL;
-
-	file = fget_light(fd, &fput_needed);
-	if (file) {
-		ret = -ESPIPE;
-		if (file->f_mode & FMODE_PREAD)
-			ret = vfs_read(file, buf, count, &pos);
-		fput_light(file, fput_needed);
+	if (pos >= 0) {
+		file = fget_light(fd, &fput_needed);
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0
+	    && (file == NULL
+		|| (lemona_file = lemona_relay_is_ours(file->f_dentry))))
+	  lemona_log(__NR_pread64, true, 3, 0, &fd, &count, &pos);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+	      lemona_get_fn(&_lemona_log, &_lemona_relay_is_ours);
+	    if (file == NULL
+			|| (lemona_file = _lemona_relay_is_ours(file->f_dentry)))
+	      _lemona_log(__NR_pread64, true, 3, 0, &fd, &count, &pos);
+	  }
+	else
+	  _lemona_log			= NULL;
+#endif
+		if (file) {
+			ret = -ESPIPE;
+			if (file->f_mode & FMODE_PREAD)
+				ret = vfs_read(file, buf, count, &pos);
+			fput_light(file, fput_needed);
+		}
 	}
+	else
+		ret = -EINVAL;
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  lemona_log(__NR_pread64, false, 2, 0, buf, &ret);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR_pread64, false, 2, 0, buf, &ret);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	return ret;
 }
 
@@ -412,17 +575,45 @@
 	ssize_t ret = -EBADF;
 	int fput_needed;
 
-	if (pos < 0)
-		return -EINVAL;
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_pwrite64, true, 4, 0, &fd, buf, &count, &pos);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR_pwrite64, true, 4, 0, &fd, buf, &count, &pos);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 
-	file = fget_light(fd, &fput_needed);
-	if (file) {
-		ret = -ESPIPE;
-		if (file->f_mode & FMODE_PWRITE)  
-			ret = vfs_write(file, buf, count, &pos);
-		fput_light(file, fput_needed);
+	if (pos >= 0) {
+		file = fget_light(fd, &fput_needed);
+		if (file) {
+			ret = -ESPIPE;
+			if (file->f_mode & FMODE_PWRITE)
+				ret = vfs_write(file, buf, count, &pos);
+			fput_light(file, fput_needed);
+		}
 	}
+	else
+		ret = -EINVAL;
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_pwrite64, false, 1, 0, &ret);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR_pwrite64, false, 1, 0, &ret);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	return ret;
 }
 
diff -uNr linux.vanilla/init/main.c linux.patch/init/main.c
--- linux.vanilla/init/main.c	2008-09-27 17:26:15.000000000 +1000
+++ linux.patch/init/main.c	2008-11-03 19:56:01.000000000 +1100
@@ -107,6 +107,11 @@
 enum system_states system_state;
 EXPORT_SYMBOL(system_state);
 
+#if defined(CONFIG_LEMONA_MODULE) || defined(CONFIG_LEMONA)
+atomic_t	lemona_activated	= ATOMIC_INIT(0);
+EXPORT_SYMBOL(lemona_activated);
+#endif
+
 /*
  * Boot command-line arguments
  */
@@ -808,6 +813,31 @@
 	(void) sys_dup(0);
 	(void) sys_dup(0);
 
+#if defined(CONFIG_LEMONA) && defined(CONFIG_LEMONA_NET_LOG)
+	/*
+	 * This is supposed to read the user passphrase and store it
+	 * so data send over the network will be encrypted.
+	 *
+	 * TODO: store the passphrase
+	 */
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		int	rd;
+		char	pass[512];
+
+		memset(pass, 0, 512);
+		printk("-==LEMONA==-" "Please enter your passphrase: ");
+		rd = sys_read(0, pass, 511);
+		if (rd > 0)
+		  {
+			pass[rd - 1] = 0; /* get rid of the newline */
+			printk("-==LEMONA==-" "Passphrase: %i - '%s'\n", rd, pass);
+		  }
+		else
+		  printk("-==LEMONA==-" "Failed to read passphrase: %i\n", rd);
+	  }
+#endif
+
 	current->signal->flags |= SIGNAL_UNKILLABLE;
 
 	if (ramdisk_execute_command) {
diff -uNr linux.vanilla/kernel/sched.c linux.patch/kernel/sched.c
--- linux.vanilla/kernel/sched.c	2008-09-27 17:26:16.000000000 +1000
+++ linux.patch/kernel/sched.c	2008-11-03 19:56:26.000000000 +1100
@@ -4188,6 +4188,8 @@
 	next = pick_next_task(rq, prev);
 
 	if (likely(prev != next)) {
+
+	  /* LEMONA (schedule): Reset protect flag and log write if needed */
 		sched_info_switch(prev, next);
 
 		rq->nr_switches++;
diff -uNr linux.vanilla/Makefile linux.patch/Makefile
--- linux.vanilla/Makefile	2008-09-27 17:26:00.000000000 +1000
+++ linux.patch/Makefile	2008-11-03 19:56:01.000000000 +1100
@@ -454,6 +454,7 @@
 net-y		:= net/
 libs-y		:= lib/
 core-y		:= usr/
+lemona-y	:= lemona/
 endif # KBUILD_EXTMOD
 
 ifeq ($(dot-config),1)
@@ -611,7 +612,7 @@
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
-		     $(net-y) $(net-m) $(libs-y) $(libs-m)))
+		     $(net-y) $(net-m) $(libs-y) $(libs-m) $(lemona-y)))
 
 vmlinux-alldirs	:= $(sort $(vmlinux-dirs) $(patsubst %/,%,$(filter %/, \
 		     $(init-n) $(init-) \
@@ -625,6 +626,7 @@
 libs-y1		:= $(patsubst %/, %/lib.a, $(libs-y))
 libs-y2		:= $(patsubst %/, %/built-in.o, $(libs-y))
 libs-y		:= $(libs-y1) $(libs-y2)
+lemona-y	:=  $(patsubst %/, %/built-in.o, $(lemona-y))
 
 # Build vmlinux
 # ---------------------------------------------------------------------------
@@ -654,7 +656,7 @@
 # System.map is generated to document addresses of all kernel symbols
 
 vmlinux-init := $(head-y) $(init-y)
-vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y)
+vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y) $(lemona-y)
 vmlinux-all  := $(vmlinux-init) $(vmlinux-main)
 vmlinux-lds  := arch/$(SRCARCH)/kernel/vmlinux.lds
 export KBUILD_VMLINUX_OBJS := $(vmlinux-all)
diff -uNr linux.vanilla/mm/mmap.c linux.patch/mm/mmap.c
--- linux.vanilla/mm/mmap.c	2008-09-27 17:26:16.000000000 +1000
+++ linux.patch/mm/mmap.c	2008-11-03 19:55:43.000000000 +1100
@@ -1130,8 +1130,8 @@
 	 */
 	if (!file && !(vm_flags & VM_SHARED) &&
 	    vma_merge(mm, prev, addr, addr + len, vm_flags,
-					NULL, NULL, pgoff, NULL))
-		goto out;
+		      NULL, NULL, pgoff, NULL))
+	  goto out;
 
 	/*
 	 * Determine the object being mapped and call the appropriate
@@ -1218,6 +1218,7 @@
 	}
 	if ((flags & MAP_POPULATE) && !(flags & MAP_NONBLOCK))
 		make_pages_present(addr, addr + len);
+	/* LEMONA (mmap): save the vma addr here if file != NULL */
 	return addr;
 
 unmap_and_free_vma:
@@ -1785,6 +1786,7 @@
 		mm->map_count--;
 		tail_vma = vma;
 		vma = vma->vm_next;
+		/* LEMONA (unmap): we need to log read/written data */
 	} while (vma && vma->vm_start < end);
 	*insertion_point = vma;
 	tail_vma->vm_next = NULL;
