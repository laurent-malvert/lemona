diff -uNr linux.vanilla/Makefile linux.lemona/Makefile
--- linux.vanilla/Makefile	2008-08-21 04:11:37.000000000 +1000
+++ linux.lemona/Makefile	2008-11-05 20:12:50.000000000 +1100
@@ -454,6 +454,7 @@
 net-y		:= net/
 libs-y		:= lib/
 core-y		:= usr/
+lemona-y	:= lemona/
 endif # KBUILD_EXTMOD
 
 ifeq ($(dot-config),1)
@@ -611,7 +612,7 @@
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
-		     $(net-y) $(net-m) $(libs-y) $(libs-m)))
+		     $(net-y) $(net-m) $(libs-y) $(libs-m) $(lemona-y)))
 
 vmlinux-alldirs	:= $(sort $(vmlinux-dirs) $(patsubst %/,%,$(filter %/, \
 		     $(init-n) $(init-) \
@@ -625,6 +626,7 @@
 libs-y1		:= $(patsubst %/, %/lib.a, $(libs-y))
 libs-y2		:= $(patsubst %/, %/built-in.o, $(libs-y))
 libs-y		:= $(libs-y1) $(libs-y2)
+lemona-y	:=  $(patsubst %/, %/built-in.o, $(lemona-y))
 
 # Build vmlinux
 # ---------------------------------------------------------------------------
@@ -654,7 +656,7 @@
 # System.map is generated to document addresses of all kernel symbols
 
 vmlinux-init := $(head-y) $(init-y)
-vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y)
+vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y) $(lemona-y)
 vmlinux-all  := $(vmlinux-init) $(vmlinux-main)
 vmlinux-lds  := arch/$(SRCARCH)/kernel/vmlinux.lds
 export KBUILD_VMLINUX_OBJS := $(vmlinux-all)
diff -uNr linux.vanilla/arch/x86/Kconfig linux.lemona/arch/x86/Kconfig
--- linux.vanilla/arch/x86/Kconfig	2008-08-21 04:11:37.000000000 +1000
+++ linux.lemona/arch/x86/Kconfig	2008-11-05 20:12:50.000000000 +1100
@@ -1729,3 +1729,5 @@
 source "arch/x86/kvm/Kconfig"
 
 source "lib/Kconfig"
+
+source "lemona/Kconfig"
diff -uNr linux.vanilla/arch/x86/mm/fault.c linux.lemona/arch/x86/mm/fault.c
--- linux.vanilla/arch/x86/mm/fault.c	2008-08-21 04:11:37.000000000 +1000
+++ linux.lemona/arch/x86/mm/fault.c	2008-11-05 20:12:50.000000000 +1100
@@ -723,6 +723,8 @@
 good_area:
 	si_code = SEGV_ACCERR;
 	write = 0;
+	/* LEMONA: if we are responsible for this fault,
+	   up_read(mm->mmap_sem) and return */
 	switch (error_code & (PF_PROT|PF_WRITE)) {
 	default:	/* 3: write, present */
 		/* fall through */
@@ -770,6 +772,7 @@
 	}
 #endif
 	up_read(&mm->mmap_sem);
+	/* LEMONA: if this was the first page_fault, log read data */
 	return;
 
 /*
diff -uNr linux.vanilla/fs/file_table.c linux.lemona/fs/file_table.c
--- linux.vanilla/fs/file_table.c	2008-08-21 04:11:37.000000000 +1000
+++ linux.lemona/fs/file_table.c	2008-11-05 20:12:50.000000000 +1100
@@ -337,6 +337,7 @@
 
 	return file;
 }
+EXPORT_SYMBOL(fget_light);
 
 
 void put_filp(struct file *file)
diff -uNr linux.vanilla/fs/namei.c linux.lemona/fs/namei.c
--- linux.vanilla/fs/namei.c	2008-08-21 04:11:37.000000000 +1000
+++ linux.lemona/fs/namei.c	2008-11-07 19:44:56.000000000 +1100
@@ -34,6 +34,9 @@
 #include <asm/namei.h>
 #include <asm/uaccess.h>
 
+#include "../lemona/lemona_patch.h"
+
+
 #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
 
 /* [Feb-1997 T. Schoebel-Theuer]
@@ -2091,12 +2094,20 @@
 	struct dentry * dentry;
 	struct nameidata nd;
 
+        lemona_block_start {
+		lemona_log_in(__NR_mknodat, 4, 0, &dfd, filename, &mode, &dev);
+        } lemona_block_end;
 	if (S_ISDIR(mode))
-		return -EPERM;
+	  {
+	    error = -EPERM;
+	    goto end;
+	  }
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
-		return PTR_ERR(tmp);
-
+	  {
+	    error = PTR_ERR(tmp);
+	    goto end;
+	  }
 	error = do_path_lookup(dfd, tmp, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
@@ -2133,13 +2144,25 @@
 	path_put(&nd.path);
 out:
 	putname(tmp);
-
+end:
+        lemona_block_start {
+		lemona_log_out(__NR_mknodat, 1, 0, &error);
+        } lemona_block_end;
 	return error;
 }
 
 asmlinkage long sys_mknod(const char __user *filename, int mode, unsigned dev)
 {
-	return sys_mknodat(AT_FDCWD, filename, mode, dev);
+	long	retval;
+
+        lemona_block_start {
+		lemona_log_in(__NR_mknod, 3, 0, filename, &mode, &dev);
+        } lemona_block_end;
+	retval = sys_mknodat(AT_FDCWD, filename, mode, dev);
+        lemona_block_start {
+		lemona_log_out(__NR_mknod, 1, 0, &retval);
+        } lemona_block_end;
+	return retval;
 }
 
 int vfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
@@ -2171,6 +2194,9 @@
 	struct dentry *dentry;
 	struct nameidata nd;
 
+        lemona_block_start {
+		lemona_log_in(__NR_mkdirat, 3, 0, &dfd, pathname, &mode);
+        } lemona_block_end;
 	tmp = getname(pathname);
 	error = PTR_ERR(tmp);
 	if (IS_ERR(tmp))
@@ -2199,12 +2225,24 @@
 out:
 	putname(tmp);
 out_err:
+        lemona_block_start {
+		lemona_log_out(__NR_mkdirat, 1, 0, &error);
+        } lemona_block_end;
 	return error;
 }
 
 asmlinkage long sys_mkdir(const char __user *pathname, int mode)
 {
-	return sys_mkdirat(AT_FDCWD, pathname, mode);
+        long	retval = 0;
+
+        lemona_block_start {
+                lemona_log_in(__NR_mkdir, 2, 0, pathname, &mode);
+        } lemona_block_end;
+        retval = sys_mkdirat(AT_FDCWD, pathname, mode);
+        lemona_block_start {
+                lemona_log_out(__NR_mkdir, 1, 0, &retval);
+        } lemona_block_end;
+	return (retval);
 }
 
 /*
@@ -2316,7 +2354,16 @@
 
 asmlinkage long sys_rmdir(const char __user *pathname)
 {
-	return do_rmdir(AT_FDCWD, pathname);
+	long	retval;
+
+        lemona_block_start {
+		lemona_log_in(__NR_rmdir, 1, 0, pathname);
+        } lemona_block_end;
+	retval = do_rmdir(AT_FDCWD, pathname);
+        lemona_block_start {
+		lemona_log_out(__NR_rmdir, 1, 0, &retval);
+        } lemona_block_end;
+	return retval;
 }
 
 int vfs_unlink(struct inode *dir, struct dentry *dentry)
@@ -2409,18 +2456,36 @@
 
 asmlinkage long sys_unlinkat(int dfd, const char __user *pathname, int flag)
 {
+        long	retval = 0;
+
+        lemona_block_start {
+	  lemona_log_in(__NR_unlinkat, 3, 0, &dfd, pathname, &flag);
+	} lemona_block_end;
 	if ((flag & ~AT_REMOVEDIR) != 0)
 		return -EINVAL;
 
 	if (flag & AT_REMOVEDIR)
 		return do_rmdir(dfd, pathname);
 
-	return do_unlinkat(dfd, pathname);
+	retval = do_unlinkat(dfd, pathname);
+	lemona_block_start {
+	  lemona_log_out(__NR_unlinkat, 1, 0, &retval);
+	} lemona_block_end;
+	return (retval);
 }
 
 asmlinkage long sys_unlink(const char __user *pathname)
 {
-	return do_unlinkat(AT_FDCWD, pathname);
+	long retval	 = 0;
+
+	lemona_block_start {
+	  lemona_log_in(__NR_unlink, 1, 0, pathname);
+	} lemona_block_end;
+	retval = do_unlinkat(AT_FDCWD, pathname);
+	lemona_block_start {
+	  lemona_log_out(__NR_unlink, 1, 0, &retval);
+	} lemona_block_end;
+	return retval;
 }
 
 int vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname, int mode)
@@ -2453,14 +2518,19 @@
 	struct dentry *dentry;
 	struct nameidata nd;
 
+        lemona_block_start {
+		lemona_log_in(__NR_symlinkat, 3, 0, oldname, &newdfd, newname);
+        } lemona_block_end;
 	from = getname(oldname);
 	if(IS_ERR(from))
-		return PTR_ERR(from);
+	  {
+		error = PTR_ERR(from);
+		goto end;
+	  }
 	to = getname(newname);
 	error = PTR_ERR(to);
 	if (IS_ERR(to))
 		goto out_putname;
-
 	error = do_path_lookup(newdfd, to, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
@@ -2483,12 +2553,25 @@
 	putname(to);
 out_putname:
 	putname(from);
+end:
+        lemona_block_start {
+		lemona_log_out(__NR_symlinkat, 1, 0, &error);
+        } lemona_block_end;
 	return error;
 }
 
 asmlinkage long sys_symlink(const char __user *oldname, const char __user *newname)
 {
-	return sys_symlinkat(oldname, AT_FDCWD, newname);
+	long	retval;
+
+        lemona_block_start {
+		lemona_log_in(__NR_symlink, 2, 0, oldname, newname);
+        } lemona_block_end;
+	retval = sys_symlinkat(oldname, AT_FDCWD, newname);
+        lemona_block_start {
+		lemona_log_out(__NR_symlink, 1, 0, &retval);
+        } lemona_block_end;
+	return retval;
 }
 
 int vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
@@ -2547,12 +2630,21 @@
 	int error;
 	char * to;
 
+	lemona_block_start {
+	  lemona_log_in(__NR_linkat, 5, 0, &olddfd, oldname, &newdfd, newname, &flags);
+	} lemona_block_end;
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
-		return -EINVAL;
+	  {
+	    error = -EINVAL;
+	    goto end;
+	  }
 
 	to = getname(newname);
 	if (IS_ERR(to))
-		return PTR_ERR(to);
+	  {
+	    error = PTR_ERR(to);
+	    goto end;
+	  }
 
 	error = __user_walk_fd(olddfd, oldname,
 			       flags & AT_SYMLINK_FOLLOW ? LOOKUP_FOLLOW : 0,
@@ -2584,13 +2676,25 @@
 	path_put(&old_nd.path);
 exit:
 	putname(to);
-
+end:
+	lemona_block_start {
+	  lemona_log_out(__NR_linkat, 1, 0, &error);
+	} lemona_block_end;
 	return error;
 }
 
 asmlinkage long sys_link(const char __user *oldname, const char __user *newname)
 {
-	return sys_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
+	long retval	 = 0;
+
+	lemona_block_start {
+	  lemona_log_in(__NR_link, 2, 0, oldname, newname);
+	} lemona_block_end;
+	retval = sys_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
+	lemona_block_start {
+	  lemona_log_out(__NR_link, 1, 0, &retval);
+	} lemona_block_end;
+	return retval;
 }
 
 /*
@@ -2827,9 +2931,14 @@
 	char * from;
 	char * to;
 
+	lemona_block_start {
+		lemona_log_in(__NR_renameat, 4, 0, olddfd, oldname, newdfd, newname);
+	} lemona_block_end;
 	from = getname(oldname);
-	if(IS_ERR(from))
-		return PTR_ERR(from);
+	if(IS_ERR(from)) {
+		error = PTR_ERR(from);
+		goto end;
+	}
 	to = getname(newname);
 	error = PTR_ERR(to);
 	if (!IS_ERR(to)) {
@@ -2837,12 +2946,24 @@
 		putname(to);
 	}
 	putname(from);
+end:
+	lemona_block_start {
+		lemona_log_out(__NR_renameat, 1, 0, &error);
+	} lemona_block_end;
 	return error;
 }
 
 asmlinkage long sys_rename(const char __user *oldname, const char __user *newname)
 {
-	return sys_renameat(AT_FDCWD, oldname, AT_FDCWD, newname);
+	long	retval;
+
+	lemona_block_start {
+		lemona_log_in(__NR_renameat, 2, 0, oldname, newname);
+	} lemona_block_end;
+	retval = sys_renameat(AT_FDCWD, oldname, AT_FDCWD, newname);
+	lemona_block_start {
+		lemona_log_out(__NR_renameat, 1, 0, &retval);
+	} lemona_block_end;
 }
 
 int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)
diff -uNr linux.vanilla/fs/open.c linux.lemona/fs/open.c
--- linux.vanilla/fs/open.c	2008-08-21 04:11:37.000000000 +1000
+++ linux.lemona/fs/open.c	2008-11-05 20:12:50.000000000 +1100
@@ -30,6 +30,8 @@
 #include <linux/audit.h>
 #include <linux/falloc.h>
 
+#include "../lemona/lemona_patch.h"
+
 int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	int retval = -ENODEV;
@@ -1110,7 +1112,44 @@
 	if (force_o_largefile())
 		flags |= O_LARGEFILE;
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_open, true, 3, 0, filename, &flags, &mode);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		if (_lemona_log == NULL)
+		  _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_open, true, 3, 0, filename, &flags, &mode);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
+
 	ret = do_sys_open(AT_FDCWD, filename, flags, mode);
+
+	/*
+	 * This should always be before asmlinkage_protect!
+	 *
+	 * We pass ret twice:
+	 *  - The first time to get the return value.
+	 *  - The second time to get the resoled filename (if fd >= 0)
+	 *
+	 */
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_open, false, 1, 1, &ret, &ret);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		if (_lemona_log == NULL)
+		  _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_open, false, 1, 1, &ret, &ret);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
+
 	/* avoid REGPARM breakage on x86: */
 	asmlinkage_protect(3, ret, filename, flags, mode);
 	return ret;
@@ -1124,7 +1163,36 @@
 	if (force_o_largefile())
 		flags |= O_LARGEFILE;
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_openat, true, 4, 0, &dfd, filename, &flags, &mode);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		if (_lemona_log == NULL)
+		  _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_openat, true, 4, 0, &dfd, filename, &flags, &mode);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
+
 	ret = do_sys_open(dfd, filename, flags, mode);
+
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_openat, false, 1, 1, &ret, &ret);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		if (_lemona_log == NULL)
+		  _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_openat, false, 1, 1, &ret, &ret);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
+
 	/* avoid REGPARM breakage on x86: */
 	asmlinkage_protect(4, ret, dfd, filename, flags, mode);
 	return ret;
@@ -1177,7 +1245,21 @@
 	struct file * filp;
 	struct files_struct *files = current->files;
 	struct fdtable *fdt;
-	int retval;
+	int retval = -EBADF;
+
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_close, true, 1, 0, &fd);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		if (_lemona_log == NULL)
+		  _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_close, true, 1, 0, &fd);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 
 	spin_lock(&files->file_lock);
 	fdt = files_fdtable(files);
@@ -1199,11 +1281,25 @@
 		     retval == -ERESTART_RESTARTBLOCK))
 		retval = -EINTR;
 
-	return retval;
+	goto out;
 
 out_unlock:
 	spin_unlock(&files->file_lock);
-	return -EBADF;
+out:
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_close, false, 1, 0, &retval);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		if (_lemona_log == NULL)
+		  _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_close, false, 1, 0, &retval);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
+	return retval;
 }
 
 EXPORT_SYMBOL(sys_close);
diff -uNr linux.vanilla/fs/read_write.c linux.lemona/fs/read_write.c
--- linux.vanilla/fs/read_write.c	2008-08-21 04:11:37.000000000 +1000
+++ linux.lemona/fs/read_write.c	2008-11-05 21:34:56.000000000 +1100
@@ -21,6 +21,9 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+#define LEMONA_READ
+#include "../lemona/lemona_patch.h"
+
 const struct file_operations generic_ro_fops = {
 	.llseek		= generic_file_llseek,
 	.read		= do_sync_read,
@@ -133,9 +136,27 @@
 	off_t retval;
 	struct file * file;
 	int fput_needed;
+#if defined(LEMONA)
+	bool lemona_file = false;
+#endif
 
 	retval = -EBADF;
 	file = fget_light(fd, &fput_needed);
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_lseek, true, 3, 0, &fd, &offset, &origin);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+		  lemona_get_fn(&_lemona_log, &_lemona_relay_is_ours);
+	    if (file == NULL
+			|| (lemona_file = _lemona_relay_is_ours(file->f_dentry)))
+		  _lemona_log(__NR_lseek, true, 3, 0, &fd, &offset, &origin);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	if (!file)
 		goto bad;
 
@@ -148,6 +169,19 @@
 	}
 	fput_light(file, fput_needed);
 bad:
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  lemona_log(__NR_lseek, false, 1, 0, &retval);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR_lseek, false, 1, 0, &retval);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	return retval;
 }
 
@@ -160,9 +194,29 @@
 	struct file * file;
 	loff_t offset;
 	int fput_needed;
+#if defined(LEMONA)
+	bool lemona_file = false;
+#endif
 
 	retval = -EBADF;
 	file = fget_light(fd, &fput_needed);
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR__llseek, true, 4, 0,
+				 &fd, &offset_high, &offset_low, &origin);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+		  lemona_get_fn(&_lemona_log, &_lemona_relay_is_ours);
+	    if (file == NULL
+			|| (lemona_file = _lemona_relay_is_ours(file->f_dentry)))
+		  _lemona_log(__NR__llseek, true, 4, 0,
+					  &fd, &offset_high, &offset_low, &origin);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	if (!file)
 		goto bad;
 
@@ -182,6 +236,20 @@
 out_putf:
 	fput_light(file, fput_needed);
 bad:
+	offset = retval == 0 ? offset : retval; /* for LEMONA */
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  lemona_log(__NR__llseek, false, 1, 0, &offset);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR__llseek, false, 1, 0, &offset);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	return retval;
 }
 #endif
@@ -355,15 +423,49 @@
 	struct file *file;
 	ssize_t ret = -EBADF;
 	int fput_needed;
+#if defined(LEMONA)
+	bool lemona_file = false;
+#endif
 
 	file = fget_light(fd, &fput_needed);
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0
+	    && (file == NULL
+			|| (lemona_file = lemona_relay_is_ours(file->f_dentry))))
+	  lemona_log(__NR_read, true, 2, 0, &fd, &count);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+	      lemona_get_fn(&_lemona_log, &_lemona_relay_is_ours);
+	    if (file == NULL
+			|| (lemona_file = _lemona_relay_is_ours(file->f_dentry)))
+		  _lemona_log(__NR_read, true, 2, 0, &fd, &count);
+	  }
+	else
+	  _lemona_log			= NULL;
+#endif
 	if (file) {
 		loff_t pos = file_pos_read(file);
 		ret = vfs_read(file, buf, count, &pos);
 		file_pos_write(file, pos);
 		fput_light(file, fput_needed);
+
 	}
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  lemona_log(__NR_read, false, 2, 0, buf, &ret);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR_read, false, 2, 0, buf, &ret);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	return ret;
 }
 
@@ -373,6 +475,20 @@
 	ssize_t ret = -EBADF;
 	int fput_needed;
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_write, true, 3, 0, &fd, buf, &count);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+		_lemona_log(__NR_write, true, 3, 0, &fd, buf, &count);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
+
 	file = fget_light(fd, &fput_needed);
 	if (file) {
 		loff_t pos = file_pos_read(file);
@@ -381,6 +497,19 @@
 		fput_light(file, fput_needed);
 	}
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_write, false, 1, 0, &ret);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR_write, false, 1, 0, &ret);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	return ret;
 }
 
@@ -390,18 +519,52 @@
 	struct file *file;
 	ssize_t ret = -EBADF;
 	int fput_needed;
+#if defined(LEMONA)
+	bool lemona_file = false;
+#endif
 
-	if (pos < 0)
-		return -EINVAL;
-
-	file = fget_light(fd, &fput_needed);
-	if (file) {
-		ret = -ESPIPE;
-		if (file->f_mode & FMODE_PREAD)
-			ret = vfs_read(file, buf, count, &pos);
-		fput_light(file, fput_needed);
+	if (pos >= 0) {
+		file = fget_light(fd, &fput_needed);
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0
+	    && (file == NULL
+		|| (lemona_file = lemona_relay_is_ours(file->f_dentry))))
+	  lemona_log(__NR_pread64, true, 3, 0, &fd, &count, &pos);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+	      lemona_get_fn(&_lemona_log, &_lemona_relay_is_ours);
+	    if (file == NULL
+			|| (lemona_file = _lemona_relay_is_ours(file->f_dentry)))
+	      _lemona_log(__NR_pread64, true, 3, 0, &fd, &count, &pos);
+	  }
+	else
+	  _lemona_log			= NULL;
+#endif
+		if (file) {
+			ret = -ESPIPE;
+			if (file->f_mode & FMODE_PREAD)
+				ret = vfs_read(file, buf, count, &pos);
+			fput_light(file, fput_needed);
+		}
 	}
+	else
+		ret = -EINVAL;
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  lemona_log(__NR_pread64, false, 2, 0, buf, &ret);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0 && lemona_file == false)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR_pread64, false, 2, 0, buf, &ret);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	return ret;
 }
 
@@ -412,17 +575,45 @@
 	ssize_t ret = -EBADF;
 	int fput_needed;
 
-	if (pos < 0)
-		return -EINVAL;
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_pwrite64, true, 4, 0, &fd, buf, &count, &pos);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR_pwrite64, true, 4, 0, &fd, buf, &count, &pos);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 
-	file = fget_light(fd, &fput_needed);
-	if (file) {
-		ret = -ESPIPE;
-		if (file->f_mode & FMODE_PWRITE)  
-			ret = vfs_write(file, buf, count, &pos);
-		fput_light(file, fput_needed);
+	if (pos >= 0) {
+		file = fget_light(fd, &fput_needed);
+		if (file) {
+			ret = -ESPIPE;
+			if (file->f_mode & FMODE_PWRITE)
+				ret = vfs_write(file, buf, count, &pos);
+			fput_light(file, fput_needed);
+		}
 	}
+	else
+		ret = -EINVAL;
 
+#if defined(CONFIG_LEMONA)
+	if (atomic_read(&lemona_activated) != 0)
+	  lemona_log(__NR_pwrite64, false, 1, 0, &ret);
+#elif defined(CONFIG_LEMONA_MODULE)
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+	    if (_lemona_log == NULL)
+	      _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+	    _lemona_log(__NR_pwrite64, false, 1, 0, &ret);
+	  }
+	else
+	  _lemona_log = NULL;
+#endif
 	return ret;
 }
 
diff -uNr linux.vanilla/init/main.c linux.lemona/init/main.c
--- linux.vanilla/init/main.c	2008-08-21 04:11:37.000000000 +1000
+++ linux.lemona/init/main.c	2008-11-05 20:12:50.000000000 +1100
@@ -107,6 +107,11 @@
 enum system_states system_state;
 EXPORT_SYMBOL(system_state);
 
+#if defined(CONFIG_LEMONA_MODULE) || defined(CONFIG_LEMONA)
+atomic_t	lemona_activated	= ATOMIC_INIT(0);
+EXPORT_SYMBOL(lemona_activated);
+#endif
+
 /*
  * Boot command-line arguments
  */
@@ -808,6 +813,31 @@
 	(void) sys_dup(0);
 	(void) sys_dup(0);
 
+#if defined(CONFIG_LEMONA) && defined(CONFIG_LEMONA_NET_LOG)
+	/*
+	 * This is supposed to read the user passphrase and store it
+	 * so data send over the network will be encrypted.
+	 *
+	 * TODO: store the passphrase
+	 */
+	if (atomic_read(&lemona_activated) != 0)
+	  {
+		int	rd;
+		char	pass[512];
+
+		memset(pass, 0, 512);
+		printk("-==LEMONA==-" "Please enter your passphrase: ");
+		rd = sys_read(0, pass, 511);
+		if (rd > 0)
+		  {
+			pass[rd - 1] = 0; /* get rid of the newline */
+			printk("-==LEMONA==-" "Passphrase: %i - '%s'\n", rd, pass);
+		  }
+		else
+		  printk("-==LEMONA==-" "Failed to read passphrase: %i\n", rd);
+	  }
+#endif
+
 	current->signal->flags |= SIGNAL_UNKILLABLE;
 
 	if (ramdisk_execute_command) {
diff -uNr linux.vanilla/kernel/sched.c linux.lemona/kernel/sched.c
--- linux.vanilla/kernel/sched.c	2008-08-21 04:11:37.000000000 +1000
+++ linux.lemona/kernel/sched.c	2008-11-05 20:12:50.000000000 +1100
@@ -4188,6 +4188,8 @@
 	next = pick_next_task(rq, prev);
 
 	if (likely(prev != next)) {
+
+	  /* LEMONA (schedule): Reset protect flag and log write if needed */
 		sched_info_switch(prev, next);
 
 		rq->nr_switches++;
diff -uNr linux.vanilla/lemona/COPYING linux.lemona/lemona/COPYING
--- linux.vanilla/lemona/COPYING	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/COPYING	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,4 @@
+This software is released under both the MIT and GPL license, the
+content of these licenses can be found respectively in the MIT.LICENSE
+and GPL.LICENSE files.
+
diff -uNr linux.vanilla/lemona/GPL.LICENSE linux.lemona/lemona/GPL.LICENSE
--- linux.vanilla/lemona/GPL.LICENSE	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/GPL.LICENSE	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff -uNr linux.vanilla/lemona/Kconfig linux.lemona/lemona/Kconfig
--- linux.vanilla/lemona/Kconfig	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/Kconfig	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,64 @@
+#
+# Lemona Configuration
+#
+
+menu "Lemona"
+
+comment "No login methods selected!"
+	depends on !LEMONA_RELAY && !LEMONA_NET_LOG && LEMONA
+
+config LEMONA
+	tristate "Enable Lemona"
+	depends on KALLSYMS && KALLSYMS_ALL
+	help
+	  Lemona is a Kernel Level monitoring system. By selecting this option
+	  every syscalls and memory mapped file will be monitored and reported.
+
+	  WARNING: Enabling this will slow down your system with more or less
+	  impact depending on its usage and characteristics.
+
+	  If unsure, say N.
+
+config	LEMONA_RELAY
+	bool "Enable relaying of log to user-land"
+	depends on LEMONA
+	depends on RELAY && DEBUG_FS
+	help
+	  Activating this option will lead Lemona to use the relay and debugfs
+	  kernel facilities to make the logs available to user land processes.
+
+	  Note: RELAY & DEBUG_FS config options need to be selected
+
+	  If unsure, say N.
+
+config	LEMONA_DEBUGFS_DIR
+	string "Name of the debugfs directory"
+	depends on LEMONA_RELAY
+	default lemona
+	help
+	  Name to be used to create the top lemona directory in the debugfs
+	  mount point.
+
+config	LEMONA_NET_LOG
+	bool "Transmit log via network"
+	depends on LEMONA
+	default y
+	help
+	  This lead Lemona to send the log via a network connection
+
+config	LEMONA_NET_LOG_SERV
+	string "Server Address"
+	default 127.0.0.1
+	depends on LEMONA_NET_LOG
+	help
+	  This should contain the server IP address.
+
+config	LEMONA_NET_LOG_PORT
+	int "Server Port"
+	default 4242
+	range 1 65535
+	depends on LEMONA_NET_LOG
+	help
+	 Port on wich to connect
+
+endmenu
diff -uNr linux.vanilla/lemona/MIT.LICENSE linux.lemona/lemona/MIT.LICENSE
--- linux.vanilla/lemona/MIT.LICENSE	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/MIT.LICENSE	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,19 @@
+Copyright (c) 2008 Kenfe-Mickaël Laventure, Laurent Malvert
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff -uNr linux.vanilla/lemona/Makefile linux.lemona/lemona/Makefile
--- linux.vanilla/lemona/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/Makefile	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,78 @@
+##
+## This file is part of Lemona.
+## Copyright (C) 2008 Kenfe-Mickaël Laventure
+##
+## The contents of this file are subject to the terms of either the
+## GNU General Public License Version 2 ("GPL") or the MIT License
+## (collectively, the "License"). You may not use this file except in
+## compliance with the License. You can obtain a copy of the License
+## at http://www.opensource.org/licenses/gpl-2.0.php and
+## http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+## and MIT.LICENSE. See the License for the specific language
+## governing permissions and limitations under the License.
+##
+
+# If KERNELRELEASE is defined, we've been invoked from the
+# kernel build system and can use its language.
+ifneq ($(KERNELRELEASE),)
+
+blades-objs				:= blades/generics.o blades/iovec.o blades/string.o
+lemona-objs				:= init.o mixers.o logging.o $(blades-objs)
+obj-$(CONFIG_LEMONA)	+= lemona.o
+
+#if relay support is needed add the relevant files
+	ifneq ($(CONFIG_LEMONA_RELAY),)
+			lemona-objs	+= relay.o
+	endif
+
+#if net support is needed add the relevant files
+	ifneq ($(CONFIG_LEMONA_NET_LOG),)
+		lemona-objs	+= net.o
+	endif
+
+# originated from command line, force CONFIG_LEMONA_RELAY declaration
+	ifneq ($(LEMONA_RELAY),)
+		EXTRA_CFLAGS		+= -DCONFIG_LEMONA_RELAY=1
+	endif
+
+# Otherwise we were called from the command
+# line; invoke the kernel build system
+else
+
+	ifneq ($(LEMONA_TARGET),)
+		UNAME	:= $(LEMONA_TARGET)
+	else
+		UNAME	:= $(shell uname -r)
+	endif
+
+	KERNELDIR	?= /lib/modules/$(UNAME)/build
+	PWD		:= $(shell pwd)
+
+	CONFIG_LEMONA	:= m
+	export CONFIG_LEMONA
+
+	ifneq ($(LEMONA_RELAY),)
+		CONFIG_LEMONA_RELAY	:= 1
+		export CONFIG_LEMONA_RELAY
+	endif
+
+	ifneq ($(LEMONA_NET_LOG),)
+		CONFIG_LEMONA_NET_LOG	:= 1
+		export CONFIG_LEMONA_NET_LOG
+	endif
+
+default:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
+
+clean:
+	@echo 'Cleaning up...'
+	@find -name '*.o' -o -name '*.ko*' -o -name '*.mod.c' 	\
+	-o -name '*.symvers' -o -name '*~' -o -name '*.order'	\
+	-o -name '*.cmd' -type f | xargs rm -f
+	@rm -rf .tmp_versions
+
+patchclean: clean
+	@find -name '.svn' -type d | xargs rm -rf
+	@find -name '*.tmp' -type f | xargs rm -f
+
+endif
diff -uNr linux.vanilla/lemona/README linux.lemona/lemona/README
--- linux.vanilla/lemona/README	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/README	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,132 @@
+Lemona Good To Know Stuff
+================================================
+
+* Supported Kernel & Architecture
+* How-To Build Using Full Patch
+* How-To Build Using Partial Patch (Developers)
+* Loading Lemona (if build as a Module)
+* Unloading Lemona (if build as a Module)
+* How-To Generate Kernel Patch (Developers)
+
+================================================
+Supported Kernel
+================================================
+
+Currently, Lemona has only be tested against the Linux 2.6.26.3
+vanilla sources. Futhermore, Lemona is only available for the x86
+architecture.
+
+================================================
+How-To Build Using Full Patch
+================================================
+
+Building Lemona as a kernel module is quite simple:
+
+  - Download the patch corresponding to your kernel:
+     wget http://lemona.googlecode.com/svn/trunk/patchs/patch-X.X.XX.X \
+     -O lemona.patch-X.X.XX.X
+
+  - Apply the patch to your kernel
+     cd $(PATH_TO_KERNEL_SRC)
+     patch -p1 < lemona_patch-X.X.XX.X
+
+  - Select the build mode for lemona in your kernel .config by using
+    make menuconfig for instance
+     make menuconfig
+       General Setup ->
+         Kernel->user space relay support (formerly relayfs)
+         Configure standard kernel features (for small systems) ->
+           Load all symbols for debugging/ksymoops
+             Include all symbol in kallsyms
+       Kernel Hacking ->
+         Debug Filesystem
+       Lemona ->
+         Enable Lemona
+
+  - Build & install your new kernel
+
+================================================
+How-To Build Using Partial Patch (Developers)
+================================================
+
+  - Checkout the lemona sources
+     svn co http://lemona.googlecode.com/svn/trunk/ lemona-read-only
+
+  - Update your kernel sources to include lemona
+     cd $(PATH_TO_KERNEL_SRC)
+     patch -p1 < $(PATH_TO_LEMONA_SRC)/patchs/patch-X.X.XX.X.partial
+     ln -s $(PATH_TO_LEMONA_SRC) lemona
+
+  - Select the build mode for lemona in your kernel .config by using
+    make menuconfig for instance
+     make menuconfig
+       Lemona ->
+         Enable Lemona
+
+  - Build & install your new kernel
+
+================================================
+Loading Lemona (if build as a Module)
+================================================
+
+To load Lemona simply use the following command:
+  insmod ./lemona.ko
+You should see a line like the following in your logs (use dmesg to see it):
+  -==Lemona==- Initialization for kernel tree 2.6.26.3...
+  -==Lemona==- Done.
+
+================================================
+Unloading Lemona (if build as a Module)
+================================================
+
+To unload Lemona simply use the following command:
+  rmmod lemona
+The following line should appear in your logs (use dmesg to see it)
+  -==Lemona==- Uninitializing...
+  -==Lemona==- Done.
+
+================================================
+How-To Generate Kernel Patch (Developers)
+================================================
+
+To generate a new lemona patch, you will need the following:
+  - a Linux Kernel vanilla untouched (i.e. you just extracted it and
+    didn't do ANYTHING else. No make menuconfig, no compilation, NOTHING).
+    We'll call it linux.vanilla.
+
+  - The same Kernel modified to support Lemona but without any object,
+    backup, vn or other uneeded files.
+    We'll call it linux.lemona
+
+  - These 2 folders should be directly accessible from a common one
+    (use symbolic links if necessary)
+
+Now, generating the patch is quite easy:
+  - Go to the directory where you can directly access both kernel sources
+
+  - Execute the following command (where X.X.XX.X is the kernel version)
+     diff -uNr linux.vanilla linux.lemona > patch-X.X.XX.X
+
+  - NOTE: Be sure NOT to have any trailing directory before either
+    linux.vanilla or linux.lemona or the standard patching method (-p1
+    option to patch) won't work
+
+  - Check your patch to ensure that it didn't include any unwanted
+    change (maybe you forgot to delete a backup file?)
+
+
+================================================
+Debugging using KGDB (VirtualBox)
+================================================
+
+ - Compile Kernel with Debug Info
+ - Configure host pipe in VirtualBox
+ - add following boot option
+	kgdboc=ttyS0,115200 kgbwait
+ - # socat -d -d /path_to_pipe/com_1 PTY:
+		2008/11/01 12:00:16 socat[14779] N successfully connected via
+		2008/11/01 12:00:16 socat[14779] N PTY is /dev/pts/7
+		2008/11/01 12:00:16 socat[14779] N starting data transfer loop with FDs [3,3] and [4,4]
+ - gdb vmlinux
+		set remotebaud 115200
+		target remote /dev/pts/7
diff -uNr linux.vanilla/lemona/blades/generics.c linux.lemona/lemona/blades/generics.c
--- linux.vanilla/lemona/blades/generics.c	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/blades/generics.c	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,209 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+#include <linux/uaccess.h> /* copy_from_user */
+
+#include "../lemona.h"
+
+
+/**
+ * lemona_blade_integer - add a 32 bits integer value to a zest
+ * @zest: The zest to be filled
+ * @isExt: Is this part of the extended arguments?
+ * @idx: Index of the value in the zest
+ * @off: Offset relative to the zest at which to copy the value
+ * @fruit1: The value to be copied (32 bits)
+ * @fruit2: Unused
+ */
+int		lemona_blade_integer(struct lemona_zest *zest,
+				     int isExt, int idx, int off,
+				     void *fruit1, void *fruit2)
+{
+  int	val = *((int *)fruit1);
+  int	*sz;
+
+  /* shall we compute the size or fill the zest ? */
+  if (zest == NULL)
+    return (sizeof(val));
+
+  /* fill the zest */
+  sz = isExt == false ? zest->argsz : zest->extsz;
+  sz[idx] = sizeof(val);
+  *((int *)((char *)zest + off)) = val;
+
+  return (sizeof(val));
+}
+
+/**
+ * lemona_blade_integer64 - add a 64 bits integer value to a zest
+ * @zest: The zest to be filled
+ * @isExt: Is this part of the extended arguments?
+ * @idx: Index of the value in the zest
+ * @off: Offset relative to the zest at which to copy the value
+ * @fruit1: The value to be copied (64 bits)
+ * @fruit2: Unused
+ */
+int		lemona_blade_integer64(struct lemona_zest *zest,
+				       int isExt, int idx, int off,
+				       void *fruit1, void *fruit2)
+{
+  u64	val = *((u64 *)fruit1);
+  int	*sz;
+
+  /* shall we compute the size or fill the zest ? */
+  if (zest == NULL)
+    return (sizeof(val));
+
+  /* fill the zest */
+  sz = isExt == false ? zest->argsz : zest->extsz;
+  sz[idx] = sizeof(val);
+  *((u64 *)((char *)zest + off)) = val;
+
+  return (sizeof(val));
+}
+
+int		lemona_blade_long(struct lemona_zest *zest,
+				  int isExt, int idx, int off,
+				  void *fruit1, void *fruit2)
+{
+  long	val = *((long *)fruit1);
+  int	*sz;
+
+  /* shall we compute the size or fill the zest ? */
+  if (zest == NULL)
+    return (sizeof(val));
+
+  /* fill the zest */
+  sz = isExt == false ? zest->argsz : zest->extsz;
+  sz[idx] = sizeof(val);
+  *((int *)((char *)zest + off)) = val;
+
+  return (sizeof(val));
+}
+
+
+/*
+ * TODO: make this an alias to lemona_blade_integer64
+ */
+int		lemona_blade_long_long(struct lemona_zest *zest,
+				       int isExt, int idx, int off,
+				       void *fruit1, void *fruit2)
+{
+  long long		val = *((long long *)fruit1);
+  int			*sz;
+
+  /* shall we compute the size or fill the zest ? */
+  if (zest == NULL)
+    return (sizeof(val));
+
+  /* fill the zest */
+  sz = isExt == false ? zest->argsz : zest->extsz;
+  sz[idx] = sizeof(val);
+  *((int *)((char *)zest + off)) = val;
+
+  return (sizeof(val));
+}
+
+/**
+ * lemona_blade_output_buffer - add the size and buffer content to a zest
+ * @zest: The zest to be filled
+ * @isExt: Is this part of the extended arguments?
+ * @idx: Starting index of the arguments
+ * @off: Offset relative to the zest from which to copy the data
+ * @buf: The buffer addresse (need to be an userspace address)
+ * @len: Size of the buffer (32 bits). If < 0, it corresponds to an ERRNO
+ *
+ * If size is negative, the return value should be sizeof(ssize_t)
+ *
+ * NOTE: As you would have guessed this is a dual blade.
+ */
+int		lemona_blade_output_buffer(struct lemona_zest *zest,
+					   int isExt, int idx, int off,
+					   void __user *buf, void *len)
+{
+  ssize_t	size	= *((ssize_t *)len);
+  int		*sz;
+  unsigned long	uncopied = size;
+
+  /* shall we compute the size or fill the zest ? */
+  if (zest == NULL)
+    return (sizeof(size) + (size >= 0 ? size : 0));
+
+  /* fill the zest */
+  sz = isExt == false ? zest->argsz : zest->extsz;
+  sz[idx] = sizeof(size);
+  *((ssize_t *)((char *)zest + off)) = size;
+
+  /* try to copy only if we actually got something to copy */
+  if (size > 0)
+    {
+      sz[idx + 1] = size;
+
+      uncopied = copy_from_user((char *)zest + off + sizeof(size),
+				buf, size);
+
+      if (uncopied)
+	{
+	  lemona_printk("(syscall %i) "
+			"output_buffer: %p/%p copied %i instead of %i\n",
+			zest->sysnr, buf, len,
+			(int)(size - uncopied), (int)size);
+	  return (-1);
+	}
+    }
+  return (sizeof(size) + (size >= 0 ? size : 0));
+}
+
+/**
+ * lemona_blade_output_buffer64 - add the size and buffer content to a zest
+ * @zest: The zest to be filled
+ * @isExt: Is this part of the extended arguments?
+ * @idx: Starting index of the arguments
+ * @off: Offset relative to the zest from which to copy the data
+ * @buf: The buffer addresse (need to be an userspace address)
+ * @len: Size of the buffer (64 bits). If < 0, it corresponds to an ERRNO
+ *
+ * If size is negative, the return value should be sizeof(s64).
+ *
+ * NOTE: As you would have guessed this is a dual blade.
+ */
+int	lemona_blade_output_buffer64(struct lemona_zest *zest,
+				     int isExt, int idx, int off,
+				     void *buf, void *len)
+{
+  s64		size	= *((u64 *)len);
+  int		*sz;
+  unsigned long	uncopied;
+
+  /* shall we compute the size or fill the zest ? */
+  if (zest == NULL)
+    return (sizeof(size) + (size >= 0 ? size : 0));
+
+  /* fill the zest */
+  sz = isExt == false ? zest->argsz : zest->extsz;
+  sz[idx] = sizeof(size);
+  *((u64 *)((char *)zest + off)) = size;
+
+  /* try to copy only if we actually got something to copy */
+  if (size > 0)
+    {
+      sz[idx + 1] = size;
+
+      uncopied = copy_from_user((char *)zest + off + sizeof(size),
+				buf, size);
+      if (uncopied)
+	return (-1);
+    }
+  return (sizeof(size) + (size >= 0 ? size : 0));
+}
diff -uNr linux.vanilla/lemona/blades/iovec.c linux.lemona/lemona/blades/iovec.c
--- linux.vanilla/lemona/blades/iovec.c	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/blades/iovec.c	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,44 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+#include <linux/uaccess.h> /* copy_from_user */
+
+#include "../lemona.h"
+
+/**
+ * lemona_blade_iovec - Add the io vector to the zest
+ * @zest: The zest to be filled
+ * @isExt: Is this part of the extended arguments?
+ * @idx: Starting index of the arguments
+ * @off: Offset relative to the zest from which to copy the data
+ * @iov: Start of the io vector
+ * @vlen: Size of the io vector
+ *
+ * If called from a call entry (zest->in == true), only append the
+ * vector content to the zest.
+ *
+ * If called from a call exit (zest->in == false), only append the
+ * data pointed by the vector. /!\ In this case, the number of bytes
+ * to be copied if to be fetch from the value stored at the previous
+ * idx.
+ *
+ * NOTE: As you would have guessed this is a dual blade.
+ */
+int		lemona_blade_iovec(struct lemona_zest *zest,
+						   int isExt, int idx, int off,
+						   void *iov, void *vlen)
+{
+  /* TODO: code lemona_blade_iovec */
+  return (0);
+}
diff -uNr linux.vanilla/lemona/blades/string.c linux.lemona/lemona/blades/string.c
--- linux.vanilla/lemona/blades/string.c	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/blades/string.c	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,124 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+#include <linux/fs.h>			/* struct file */
+#include <linux/slab.h>			/* kzalloc */
+#include <linux/limits.h>		/* PATH_MAX */
+#include <linux/file.h>			/* struct file, fget_light, fput_light */
+#include <linux/uaccess.h>		/* strncopy_from_user */
+
+#include "../lemona.h"
+
+/**
+ * lemona_blade_string_null - Append the content of a null terminated string
+ * @zest: The zest to be filled
+ * @isExt: Is this part of the extended arguments?
+ * @idx: Index of the string in the arguments
+ * @off: Offset relative to the zest from which to copy the data
+ * @str: String address (user space address)
+ * @unused: well... it's unused ;-)
+ *
+ * TODO: shall we return PATH_MAX instead of getting the real size?
+ * Is speed better than wasted space in zest?
+ */
+int		lemona_blade_string_null(struct lemona_zest *zest,
+					 int isExt, int idx, int off,
+					 void __user *str, void *unused)
+{
+  long		len;
+  int		*sz;
+
+  /* shall we compute the size or fill the zest ? */
+  if (zest == NULL)
+    {
+      char	*buf;
+
+      buf = kzalloc(PATH_MAX, GFP_KERNEL);
+      if (buf == NULL)
+	return (-ENOMEM);
+
+      len = strncpy_from_user(buf, str, PATH_MAX);
+      kfree(buf);
+      return (len + 1); /* add place for \0 since strncpy copy it too */
+    }
+
+  /* fill the zest */
+  sz = isExt == false ? zest->argsz : zest->extsz;
+  /* copy and get size */
+  len = strncpy_from_user((char *)zest + off, str, PATH_MAX);
+  sz[idx] = len + 1; /* don't forget the \0, since it is copied too */
+  return (len + 1);
+}
+
+/**
+ * lemona_blade_string_fd - Append the path of a file descriptor
+ * @zest: The zest to be filled
+ * @isExt: Is this part of the extended arguments?
+ * @idx: Index of the string in the arguments
+ * @off: Offset relative to the zest from which to copy the data
+ * @pfd: Pointer to the fd
+ * @unused: well... it's unused ;-)
+ *
+ * TODO: do we need to lock the dentry while going through it?
+ */
+int		lemona_blade_string_fd(struct lemona_zest *zest,
+				       int isExt, int idx, int off,
+				       void *pfd, void *unused)
+{
+  long		fd		= *((long *)pfd);
+  int		size	= 0;
+  struct file	*file;
+  struct dentry	*dentry;
+  int		fput_needed;
+  char		*dest;
+  int		*sz;
+
+  /* if the fd is invalid no need to go further */
+  if (fd < 0 || (file = fget_light(fd, &fput_needed)) == NULL)
+    return (size);
+
+  dentry = file->f_dentry;
+
+  /* shall we compute the size or fill the zest ? */
+  if (zest == NULL)
+    {
+      while (dentry != dentry->d_parent)
+	{
+	  /* add space for '/' separator */
+	  size			+= (int)dentry->d_name.len + (size ? 1 : 0);
+	  dentry		= dentry->d_parent;
+	}
+
+      fput_light(file, fput_needed);
+      return (size + 1); /* add '/' (i.e. root path) */
+    }
+
+  /* fill the zest */
+  sz	= isExt == false ? zest->argsz : zest->extsz;
+  dest	= (char *)zest + off;
+  while (dentry != dentry->d_parent)
+    {
+      /* add '/' separator if needed */
+      if (size)
+	dest[size++]		= '/';
+      strncpy(dest + size, dentry->d_name.name, dentry->d_name.len);
+      size				+= (int)dentry->d_name.len;
+      dentry			= dentry->d_parent;
+    }
+  /* add '/' (i.e. root path) */
+  dest[size++]	= '/';
+  sz[idx]		= size;
+  fput_light(file, fput_needed);
+  return (size);
+}
diff -uNr linux.vanilla/lemona/init.c linux.lemona/lemona/init.c
--- linux.vanilla/lemona/init.c	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/init.c	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,86 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+#include <linux/init.h>		/* module_* */
+#include <linux/module.h>	/* MODULE_LICENSE */
+#include <linux/utsrelease.h>	/* UTS_RELEASE */
+
+#include "lemona.h"
+
+MODULE_LICENSE("Dual MIT/GPL");
+
+#if defined(CONFIG_LEMONA_MODULE)
+extern atomic_t			lemona_clients;
+# define lemona_clients_wait()			\
+  while (atomic_read(&lemona_clients) > 0)	\
+    schedule();
+#else
+# define lemona_clients_wait()
+#endif
+
+struct lemona			*juice			= NULL;
+
+static void			lemona_cleanup(void)
+{
+  lemona_relay_cleanup();
+  lemona_net_cleanup();
+  if (juice)
+    kfree(juice);
+}
+
+static int __init		lemona_init(void)
+{
+  long					err = 0;
+  extern atomic_t		lemona_activated;
+
+  lemona_printk("Initialization for kernel tree " UTS_RELEASE "...\n");
+  juice = kzalloc(sizeof(*juice), GFP_KERNEL);
+  if (juice == NULL)
+    {
+      err = -ENOMEM;
+      goto err;
+    }
+  err = lemona_relay_init();
+  if (err)
+    goto err;
+  err = lemona_net_init(true);
+  if (err < 0)
+    goto err;
+  lemona_printk("Done.\n");
+  atomic_set(&lemona_activated, 1);
+  return (0);
+
+ err:
+  lemona_cleanup();
+  lemona_printk("Failed.\n");
+  return (err);
+}
+
+static void __exit		lemona_exit(void)
+{
+  extern atomic_t		lemona_activated;
+
+  lemona_printk("Uninitializing Lemona...\n");
+  atomic_set(&lemona_activated, 0);
+  /*
+   * Wait until our last client finish working.
+   * Their logs will be lost anyway, but we don't want to generate an Oops
+   */
+  lemona_clients_wait();
+  lemona_cleanup();
+  lemona_printk("Done.\n");
+}
+
+module_init(lemona_init);
+module_exit(lemona_exit);
diff -uNr linux.vanilla/lemona/lemona.h linux.lemona/lemona/lemona.h
--- linux.vanilla/lemona/lemona.h	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/lemona.h	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,138 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+#ifndef _LEMONA_H_
+# define _LEMONA_H_
+
+# ifdef __KERNEL__
+#  include <linux/time.h>	/* struct timespec */
+# else
+#  include <time.h>		/* struct timespec */
+# endif
+
+/*
+ * Every single log entry is represented by a zest.
+ */
+struct	lemona_zest {
+  char			magic[4];
+  int			size;  	/* size taken by this zest and args sz/value */
+
+  int			in;
+  struct timespec	time;	/* call start/end time (getnstimeofday) */
+
+  pid_t			pid;	/* actual pid */
+  pid_t 		tgid;	/* thread group id */
+
+  uid_t			uid,euid,fsuid;	/* don't care about the suid ? */
+  gid_t			gid,egid,fsgid;	/* don't care about the sgid ? */
+
+  int			sysnr; 	/* syscall id */
+  int			argnr;	/* number of args */
+
+  /*
+   * Pointer to an array of int indicating the size taken by each
+   * argument this table is located directy after this structure.
+   */
+  int			*argsz;
+  /*
+   * Pointer to the first argument value. its should be placed just
+   * after the end of argsz. Every args value are one after the
+   * other.
+   */
+  void			*args;
+
+  int			extnr;	/* extra value number */
+  int			*extsz;	/* size of each extension */
+  void			*exts;	/* extra values. located after the last arg */
+} __attribute__((packed));
+
+# ifdef __KERNEL__
+
+#  include "lemona_net.h"
+#  include "lemona_relay.h"
+#  include "lemona_blades.h"
+
+/*
+ * So it'll be easier to spot lemona messages.
+ *
+ * The token paste operator (i.e. ##) is used to avoid a warning if no
+ * trailing arguments are provided (see the GCC C Extension manual).
+ */
+#  define LEMONA_PRINTK_PREFIX	" -==Lemona==- "
+#  define lemona_printk(s, ...)	printk(LEMONA_PRINTK_PREFIX s, ## __VA_ARGS__)
+
+/*
+ * We're going to have one handler for each arg/ext.
+ */
+/*
+ * These functions are used in two different maneers:
+ *  - if dest is NULL, the space required by the argument is to be returned
+ *  - if dest is not NULL, the argument should be placed in the structure
+ *    and the number of written byte returned (this should match the value
+ *    returned if zest was to be NULL).
+ */
+/**
+ * bladefn - function pointer for blades
+ * @zest: The zest to be filled or NULL if only size is to be computed
+ * @isExt: Is the given arg(s) are part of the extended values?
+ * @idx: Index of the first value (either in args or exts).
+ * @off: Offset at which to write the first value
+ * @fruit1: The first value
+ * @fruit2: The second value
+ */
+typedef int	(*bladefn)(struct lemona_zest *zest, int isExt,
+					   int idx, int off,
+					   void *fruit1, void *fruit2);
+
+struct	__lemona_mixer_handler {
+  bool		dual;
+  bladefn	blade;
+};
+
+struct	__lemona_mixer {
+  int				argnr;
+  int				extnr;
+  struct __lemona_mixer_handler	handlers[6];
+};
+
+/*
+ * We have several mixer, one for each syscall. We use the array
+ * declared in mixers.c to have a kind of automated way of logging
+ * syscall events.
+ */
+struct	lemona_mixer {
+  int			sysnr;
+  struct __lemona_mixer	in;
+  struct __lemona_mixer	out;
+};
+
+/*
+ * Contains all information needed by lemona throughout the module.
+ */
+struct	lemona {
+  struct lemona_relay	relay;
+  struct lemona_net	net;
+};
+
+typedef int	(*lemonalogfn)(int sysnr, int in, int argnr, int extnr, ...);
+
+/*
+ * Prototypes
+ */
+extern int		lemona_log(int sysnr, int in,
+						   int argnr, int extnr, ...);
+
+# endif /* __KERNEL __ */
+
+#endif
diff -uNr linux.vanilla/lemona/lemona_blades.h linux.lemona/lemona/lemona_blades.h
--- linux.vanilla/lemona/lemona_blades.h	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/lemona_blades.h	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,59 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+#ifndef _LEMONA_BLADES_H_
+# define _LEMONA_BLADES_H_
+
+struct lemona_zest;
+
+/*
+ * from blades/generics.c
+ */
+int		lemona_blade_integer(struct lemona_zest *zest,
+							 int isExt, int idx, int off,
+							 void *fruit1, void *fruit2);
+
+int		lemona_blade_integer64(struct lemona_zest *zest,
+							   int isExt, int idx, int off,
+							   void *fruit1, void *fruit2);
+
+int		lemona_blade_long(struct lemona_zest *zest,
+						  int isExt, int idx, int off,
+						  void *fruit1, void *fruit2);
+
+int		lemona_blade_long_long(struct lemona_zest *zest,
+							   int isExt, int idx, int off,
+							   void *fruit1, void *fruit2);
+
+/* this is a dual blade */
+int		lemona_blade_output_buffer(struct lemona_zest *zest,
+								   int isExt, int idx, int off,
+								   void *fruit1, void* fruit2);
+
+/* this is a dual blade */
+int		lemona_blade_output_buffer64(struct lemona_zest *zest,
+									 int isExt, int idx, int off,
+									 void *fruit1, void* fruit2);
+
+/*
+ * from blades/string.c
+ */
+int		lemona_blade_string_null(struct lemona_zest *zest,
+								 int isExt, int idx, int off,
+								 void __user *str, void *unused);
+int		lemona_blade_string_fd(struct lemona_zest *zest,
+							   int isExt, int idx, int off,
+							   void __user *str, void *unused);
+
+#endif
diff -uNr linux.vanilla/lemona/lemona_net.h linux.lemona/lemona/lemona_net.h
--- linux.vanilla/lemona/lemona_net.h	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/lemona_net.h	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,66 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+#ifndef _LEMONA_NET_H_
+# define _LEMONA_NET_H_
+
+# if defined(CONFIG_LEMONA_NET_LOG)
+
+#  include <linux/in.h>		/* AF_INET, IPPROTO_TCP, struct sockaddr_in */
+#  include <linux/net.h>	/* SOCK_STREAM */
+#  include <linux/socket.h>	/* sock_*, kernel_* */
+
+#  include <linux/mutex.h>	/* take a guess ;-) */
+
+
+/*
+ * This can be overrided via the kernel config or module parameter
+ */
+#  ifndef CONFIG_LEMONA_NET_LOG_SERV
+#   define CONFIG_LEMONA_NET_LOG_SERV	"127.0.0.1"
+#  endif
+
+/*
+ * This can be overrided via the kernel config or module parameter
+ */
+#  ifndef CONFIG_LEMONA_NET_LOG_PORT
+#   define CONFIG_LEMONA_NET_LOG_PORT	4242
+#  endif
+
+/* How many seconds shall we wait before trying to reconnect to the server? */
+# define NET_LOG_RETRY	60
+
+struct lemona_net {
+  struct mutex		lock;
+  unsigned long		timeout;
+
+  struct sockaddr_in	sin;
+  struct socket		*sock;
+};
+
+int	lemona_net_init(bool init);
+void	lemona_net_log(struct lemona_zest *zest);
+void	lemona_net_cleanup(void);
+
+# else /* CONFIG_LEMONA_NET_LOG */
+
+struct lemona_net { };
+
+# define lemona_net_init(x)	0
+# define lemona_net_log(x)
+# define lemona_net_cleanup()
+
+# endif /* CONFIG_LEMONA_NET_LOG */
+
+#endif
diff -uNr linux.vanilla/lemona/lemona_patch.h linux.lemona/lemona/lemona_patch.h
--- linux.vanilla/lemona/lemona_patch.h	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/lemona_patch.h	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,82 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+/*
+ * File to be included in every kernel sources file to be patched.
+ */
+
+#ifndef _LEMONA_PATCH_H_
+# define _LEMONA_PATCH_H_
+
+# if defined(CONFIG_LEMONA) || defined(CONFIG_LEMONA_MODULE)
+#  include <linux/kallsyms.h>
+#  include <../lemona/lemona.h>
+
+/*
+ * add this define to avoid testing for CONFIG_LEMONA && CONFIG_LEMONA_MODULE
+ */
+# define LEMONA	1
+
+/*
+ * Variable
+ */
+extern atomic_t			lemona_activated;
+
+#  define lemona_block_start			\
+  if (atomic_read(&lemona_activated) != 0)	\
+    {
+
+
+#  define lemona_log_in(sysnr, argnr, extnr, ...)	__lemona_log(sysnr, true, argnr, extnr, ## __VA_ARGS__)
+#  define lemona_log_out(sysnr, argnr, extnr, ...)	__lemona_log(sysnr, false, argnr, extnr, ## __VA_ARGS__)
+
+#  if defined(CONFIG_LEMONA_MODULE)
+
+static lemonalogfn		_lemona_log		= NULL;
+
+#   define lemona_block_end			\
+    }						\
+  else						\
+    {						\
+      _lemona_log = NULL;			\
+    }
+
+#define __lemona_log(sysnr, in, argnr, extnr, ...)	{		\
+  if (_lemona_log == NULL)						\
+    _lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");	\
+  _lemona_log(sysnr, in, argnr, extnr, ## __VA_ARGS__);		        \
+}
+
+#   if defined(LEMONA_READ)
+static lemonarelayisoursfn	_lemona_relay_is_ours	= NULL;
+
+void inline lemona_get_fn(lemonalogfn *_lemona_log,
+			  lemonarelayisoursfn *_lemona_relay_is_ours)
+{
+  *_lemona_log = (lemonalogfn)kallsyms_lookup_name("lemona_log");
+  *_lemona_relay_is_ours = (lemonarelayisoursfn)kallsyms_lookup_name("lemona_relay_is_ours");
+}
+#   endif /* LEMONA_READ */
+#  elif /* CONFIG_LEMONA */
+
+#  define lemona_block_end			\
+    }
+
+
+#   define __lemona_log(sysnr, in, argnr, extnr, ...)	lemona_log(sysnr, in, argnr, extnr, ## __VA_ARGS__)
+
+#  endif /* CONFIG_LEMONA_MODULE */
+# endif /* CONFIG_LEMONA || CONFIG_LEMONA_MODULE */
+
+#endif /* _LEMONA_PATCH_H_ */
diff -uNr linux.vanilla/lemona/lemona_relay.h linux.lemona/lemona/lemona_relay.h
--- linux.vanilla/lemona/lemona_relay.h	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/lemona_relay.h	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,99 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+#ifndef _LEMONA_RELAY_H_
+# define _LEMONA_RELAY_H_
+
+# ifdef CONFIG_LEMONA_RELAY
+
+#  include <linux/relay.h>	/* relay */
+#  include <linux/debugfs.h>	/* debugfs */
+
+
+
+/*
+ * This can be overrided via the kernel config or module parameter
+ */
+#  ifndef CONFIG_LEMONA_DEBUGFS_DIR
+#   define CONFIG_LEMONA_DEBUGFS_DIR	"lemona"
+#  endif
+
+/*
+ * Size of a sub-buffer in relay?
+ */
+#  ifndef CONFIG_LEMONA_RELAY_SBUF_SZ
+#   define CONFIG_LEMONA_RELAY_SBUF_SZ	(256 * 1024)
+#  endif
+
+/*
+ * Number of sub-buffer in relay?
+ */
+#  ifndef CONFIG_LEMONA_RELAY_SBUF_NR
+#   define CONFIG_LEMONA_RELAY_SBUF_NR	(4)
+#  endif
+
+/*
+ * Since a log entry is a zest, lot of them give us a lemon, right...?
+ */
+# define LEMONA_RELAY_CHANNEL_NAME	"lemon"
+
+struct lemona_relay_file {
+  struct list_head	next;
+  struct dentry		*d;
+};
+
+struct lemona_relay {
+  /*
+   * Hold the struct returned by debugfs during init.
+   * The directory will use the value of CONFIG_LEMONA_DEBUGFS_DIR.
+   * This is overridable during module loading and from the kernel config.
+   */
+  struct dentry		*dir;
+  /*
+   * Structure designing the channel created by relay for us to use
+   */
+  struct rchan		*chan;
+
+  /*
+   * Lit of files (struct dentry) created for relay
+   */
+  struct list_head	files;
+};
+
+#  define rchan		relay.chan
+#  define dfs_dir	relay.dir
+
+struct lemona_zest;
+
+int __init	lemona_relay_init(void);
+void		lemona_relay_cleanup(void);
+int		lemona_relay_log(const struct lemona_zest *);
+
+typedef bool	(*lemonarelayisoursfn)(const struct dentry *dentry);
+bool		lemona_relay_is_ours(const struct dentry *dentry);
+
+# else /*  CONFIG_LEMONA_RELAY */
+
+struct lemona_relay { };
+
+#  define lemona_relay_init()	 0
+#  define lemona_relay_cleanup()
+#  define lemona_relay_log(z)	0
+#  define lemona_relay_is_ours(d) false
+
+typedef bool (*lemonarelayisoursfn)(void *);
+
+# endif /* CONFIG_LEMONA_RELAY */
+
+#endif
diff -uNr linux.vanilla/lemona/logging.c linux.lemona/lemona/logging.c
--- linux.vanilla/lemona/logging.c	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/logging.c	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,359 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+#include <stdarg.h>			/* va_* */
+
+#include <linux/err.h>		/* ERR_PTR, PTR_ERR, IS_ERR */
+#include <linux/slab.h>		/* kzalloc */
+#include <linux/sched.h>	/* task_struct, current */
+
+#include "lemona.h"
+
+extern const struct lemona_mixer		lemona_mixers[];
+extern const int						lemona_mixers_size;
+
+#if defined (CONFIG_LEMONA_MODULE)
+atomic_t				lemona_clients	= ATOMIC_INIT(0);
+# define lemona_clients_inc() atomic_inc(&lemona_clients)
+# define lemona_clients_dec() atomic_dec(&lemona_clients)
+#else
+# define lemona_clients_inc(x)
+# define lemona_clients_dec(x)
+#endif
+
+/**
+ * lemona_zest_get_size - Compute the size needed by a zest
+ * @mixer: The mixer containing information on how to handle this zest values
+ * @in: Is this at the entry or exit of a call?
+ * @ap: Beginning of the arguments
+ *
+ * For each argument, the corresponding blade will be invoked with a
+ * NULL zest as parameter. This will hint the blade to simply return
+ * the size required to store the current argument value. All returned
+ * values are then added together along with the lemona_zest struct
+ * size and the space needed to hold the size of each value.
+ */
+static int	lemona_zest_get_size(const struct lemona_mixer *mixer,
+				     int in, va_list ap)
+{
+  int					i	= 0;
+  int					tmp	= 0;
+  int					size	= 0;
+  int					bladesnr;
+  const struct __lemona_mixer_handler	*handlers;
+  void					*arg1, *arg2;
+
+  if (unlikely(mixer == NULL))
+    return (-EINVAL);
+
+  if (in == true)
+    {
+      handlers	= mixer->in.handlers;
+      bladesnr	= mixer->in.argnr + mixer->in.extnr;
+    }
+  else
+    {
+      handlers	= mixer->out.handlers;
+      bladesnr	= mixer->out.argnr + mixer->out.extnr;
+    }
+  /* one blade for each arg then for each ext */
+  for (i = 0; i < bladesnr; i += handlers[i].dual ? 2 : 1)
+    {
+      if (handlers[i].blade == NULL)
+	{
+	  lemona_printk("lemona_zest_get_size: Invalid mixer blade:\n");
+	  lemona_printk("\tsysnr: %i\n", mixer->sysnr);
+	  lemona_printk("\tblade: %i\n", i);
+	  lemona_printk("\tin: %s\n", in ? "true" : "false");
+	  return (-EINVAL);
+	}
+      arg1 = va_arg(ap, void*);
+      if (handlers[i].dual == true)
+	{
+	  arg2	= va_arg(ap, void*);
+	  tmp	= handlers[i].blade(NULL, false, i, 0, arg1, arg2);
+	}
+      else
+	tmp	= handlers[i].blade(NULL, false, i, 0, arg1, NULL);
+      if (tmp < 0)
+	{
+	  lemona_printk("lemona_zest_get_size: "
+			"Unable to determine argument size:\n");
+	  lemona_printk("\tsysnr: %i\n", mixer->sysnr);
+	  lemona_printk("\tblade: %i\n", i);
+	  lemona_printk("\tin: %s\n", in ? "true" : "false");
+	  lemona_printk("\tret: %i\n", tmp);
+	  return (tmp);
+	}
+      size += tmp;
+    }
+  /* we're adding space for the zest itself and the args/exts size array */
+  return (sizeof(struct lemona_zest) + (bladesnr * sizeof(int)) + size);
+}
+
+/**
+ * lemona_zest_fill - Fill a zest with the values pointed by ap
+ * @mixer: The mixer containing information on how to handle this zest values
+ * @in: Is this at the entry or exit of a call?
+ * @z: The zest to be filled (has been allocated by lemona_zest_create)
+ * @ap: Beginning of the arguments
+ *
+ * This will fill the zest with common info then invoke the differents
+ * blades to copy the needed arguments in the zest buffer.
+ *
+ * NOTE: the timestamp is only generated in saved at this point so
+ * far. It might be moved earlier in the code path later on.
+ */
+static int	lemona_zest_fill(const struct lemona_mixer *mixer,
+				 int in, struct lemona_zest *z,
+				 va_list ap)
+{
+  int					i;
+  int					off		= 0;
+  int					ret		= 0;
+  const struct __lemona_mixer_handler	*handlers;
+  void					*arg1, *arg2;
+
+  strncpy(z->magic, "ZeSt", 4);
+
+  /* we don't check our arguments, this should have already been done */
+  getnstimeofday(&(z->time));
+  z->in		= in;
+
+  z->pid	= current->pid;
+  z->tgid	= current->tgid;
+
+  z->uid	= current->uid;
+  z->euid	= current->euid;
+  z->fsuid	= current->fsuid;
+
+  z->gid	= current->gid;
+  z->egid	= current->egid;
+  z->fsgid	= current->fsgid;
+
+  z->sysnr	= mixer->sysnr;
+  if (in == true)
+    {
+      z->argnr	= mixer->in.argnr;
+      z->extnr	= mixer->in.extnr;
+    }
+  else
+    {
+      z->argnr	= mixer->out.argnr;
+      z->extnr	= mixer->out.extnr;
+    }
+  z->argsz	= (int *)(z + 1);  /* located right after this struct */
+  z->args	= z->argsz + z->argnr; /* located right after z->argsz */
+
+  /*
+   * Which blades to use?
+   */
+  if (in == true)
+    handlers	= mixer->in.handlers;
+  else
+    handlers	= mixer->out.handlers;
+
+  /*
+   * Lets put our args into our zest
+   */
+  off = (int)((char *)z->args - (char *)z);
+  for (i = 0; i < z->argnr; i += handlers[i].dual ? 2 : 1)
+    {
+      arg1 = va_arg(ap, void*);
+      if (handlers[i].dual == true)
+	{
+	  arg2	= va_arg(ap, void*);
+	  ret	= handlers[i].blade(z, false, i, off, arg1, arg2);
+	}
+      else
+	ret	= handlers[i].blade(z, false, i, off, arg1, NULL);
+      if (ret < 0)
+	{
+	  lemona_printk("args (syscal %i) in: %i blade %i returned -1\n",
+			mixer->sysnr, in, i);
+	  goto out;
+	}
+      off		= off + ret;
+    }
+
+  /*
+   * Now it's the exts turn. (yes, I could have made a small function/macro)
+   */
+  z->extsz	= (int *)((char *)z + off); /* just after the last arg value */
+  z->exts	= z->extsz + z->extnr; /* located right after z->extsz */
+  off		= (int)((char *)z->exts - (char *)z);
+  for (i = 0; i < z->extnr; i += handlers[i].dual ? 2 : 1)
+    {
+      arg1 = va_arg(ap, void*);
+      if (handlers[z->argnr + i].dual == true)
+	{
+	  arg2	= va_arg(ap, void*);
+	  ret	= handlers[z->argnr + i].blade(z, true, i, off, arg1, arg2);
+	}
+      else
+	ret	= handlers[z->argnr + i].blade(z, true, i, off, arg1, NULL);
+      if (ret < 0)
+	{
+	  lemona_printk("exts (syscal %i) in: %i blade %i returned %i\n",
+			mixer->sysnr, in, i, ret);
+	  goto out;
+	}
+      off		= off + ret;
+    }
+
+ out:
+  return (ret < 0 ? ret : off);
+}
+
+/**
+ * lemona_zest_create - generate a new zest to be added to the log
+ * @mixer: mixer to use to create this zest
+ * @in: is this the entry or exit log?
+ * @argnr: number of arguments of this syscall (for error checking)
+ * @extnr: number of extra arguments for this syscall (for error checking)
+ *
+ * This is simply a generic way of handling the zest generation for
+ * syscall it should avoid duplicating code in kernel patches and
+ * provide for easier addition of yep unsupported syscall monitoring.
+ *
+ * TODO: shall we pass the timespec struct here? Which mean it would
+ * be computed straight after the syscall has been entered.
+ */
+static struct lemona_zest *lemona_zest_create(const struct lemona_mixer *mixer,
+					      int in, int argnr, int extnr,
+					      va_list ap)
+{
+  int				zsz	= 0;
+  struct lemona_zest		*z	= ERR_PTR(-ENOMEM);
+  const struct __lemona_mixer	*inout;
+
+  inout = in == true ? &(mixer->in) : &(mixer->out);
+  if (inout->argnr != argnr || inout->extnr != extnr)
+    {
+      lemona_printk("Conflicting values for syscall %i:\n", mixer->sysnr);
+      lemona_printk("argnr: %i instead of %i\n", argnr, inout->argnr);
+      lemona_printk("extnr: %i instead of %i\n", extnr, inout->extnr);
+      lemona_printk("in: %s\n", in ? "true" : "false");
+      lemona_printk("idx: %i\n",
+		    (int)((char *)mixer - (char *)lemona_mixers)
+		    / sizeof(*mixer));
+      return (ERR_PTR(-EINVAL));
+    }
+  zsz = lemona_zest_get_size(mixer, in, ap);
+  if (zsz > 0)
+    {
+      z = kzalloc(zsz, GFP_KERNEL);
+      if (z != NULL)
+	z->size = zsz;
+      else
+	{
+	  lemona_printk("(syscall %i) Unable to create zest with size: %i\n",
+			mixer->sysnr, zsz);
+	  z = ERR_PTR(-ENOMEM);
+	}
+    }
+  return (z);
+}
+
+/**
+ * lemona_log - generate a new zest and add it to the log
+ * @sysnr: syscall being monitored
+ * @in: is this the entry or exit log?
+ * @argnr: number of arguments of this syscall (for error checking)
+ * @extnr: number of extra arguments for this syscall (for error checking)
+ *
+ * This is simply a generic way of handling a syscall monitoring it
+ * should allow us to avoid duplicating code in kernel patches and
+ * provide for easier addition of yep unsupported syscall monitoring.
+ *
+ * NOTE: All arguments should be passed as pointer, even integers. The
+ * mixers blades will be responsible to cast them in the type they're
+ * expecting to handle.
+ *
+ * TODO: shall we pass the timespec struct here? Which mean it would
+ * be computed straight after the syscall has been entered.
+ */
+int			lemona_log(int sysnr, int in,
+				   int argnr, int extnr, ...)
+{
+  va_list		ap;
+  int			i;
+  int			ret	= 0;
+  struct lemona_zest	*z	= NULL;
+
+  lemona_clients_inc();
+
+  /* look for the right mixer */
+  if (likely(sysnr < lemona_mixers_size
+	     && lemona_mixers[sysnr].sysnr == sysnr))
+    i = sysnr;
+  else if (unlikely(lemona_mixers[sysnr].sysnr != sysnr
+		    && lemona_mixers[sysnr].sysnr != -1)) /* uhuh... */
+    {
+      lemona_printk("Mixer array is corrupted: %i != %i (%i total)\n",
+		    sysnr,
+		    lemona_mixers[sysnr].sysnr,
+		    lemona_mixers_size);
+      lemona_clients_dec();
+      return (-EINVAL);
+    }
+  else /* lemona_mixers[sysnr].sysnr == -1 || out of bound */
+    {
+      lemona_printk("No mixer found for syscall: %i\n", sysnr);
+      lemona_clients_dec();
+      return (-EINVAL);
+    }
+
+  /* let's mix! */
+  va_start(ap, extnr);
+  z = lemona_zest_create(lemona_mixers + i, in, argnr, extnr, ap);
+  if (IS_ERR(z))
+    {
+      ret		= PTR_ERR(z);
+      z			= NULL;
+      goto out; /* TODO: What should we do in this case? */
+    }
+
+  /*
+   * We need to reset the ap to the beginning of the arguments
+   * before trying to fill our zest.
+   */
+  va_end(ap);
+  va_start(ap, extnr);
+  ret = lemona_zest_fill(lemona_mixers + i, in, z, ap);
+  if (ret != z->size)
+    {
+      lemona_printk("zest_fill returned a different "
+		    "value than zest_get_size (syscall %i): "
+		    "%i instead of %i\n",
+		    sysnr, ret, z->size);
+      ret = -EINVAL;
+      goto out;
+    }
+  ret = 0;
+
+  /*
+   * TODO: call the different logging facilities:
+   *  - lemona_relay_log
+   *  - ...
+   */
+  lemona_relay_log(z);
+  lemona_net_log(z);
+
+ out:
+  va_end(ap);
+  kfree(z); /* it handles NULL pointer, no worries ;-) */
+  lemona_clients_dec();
+  return (ret);
+}
diff -uNr linux.vanilla/lemona/mixers.c linux.lemona/lemona/mixers.c
--- linux.vanilla/lemona/mixers.c	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/mixers.c	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,5732 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+#include <linux/unistd.h> /* __NR* */
+
+#include "lemona.h"
+
+const struct lemona_mixer	lemona_mixers[]= {
+  {
+    .sysnr	= __NR_restart_syscall,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_exit,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fork,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_read,
+    .in		= {
+      .argnr	= 2,
+      .extnr	= 0,
+      .handlers	= {
+	/* fd */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+	/* count */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+      }
+    },
+    .out	= {
+      .argnr	= 2,
+      .extnr	= 0,
+      .handlers	= {
+	/* buf & ret (in this order) */
+	{ .dual = true	, .blade = lemona_blade_output_buffer	},
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_write,
+    .in		= {
+      .argnr	= 3,
+      .extnr	= 0,
+      .handlers	= {
+	/* fd */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+	/* buf & count (in this order) */
+	{ .dual	= true	, .blade = lemona_blade_output_buffer	},
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+	/* return value */
+	{ .dual = false	, .blade = lemona_blade_integer			},
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_open,
+    .in		= {
+      .argnr	= 3,
+      .extnr	= 0,
+      .handlers	= {
+	/* filename (user null terminated string) */
+	{ .dual	= false	, .blade = lemona_blade_string_null		},
+	/* flags */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+	/* mode */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 1,
+      .handlers	= {
+	/* ret */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+	/* get resolved path from fd (i.e. ret) */
+	{ .dual = false	, .blade = lemona_blade_string_fd		},
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_close,
+    .in		= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+	/* fd */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+	/* ret */
+	{ .dual = false	, .blade = lemona_blade_integer			},
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_waitpid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_creat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_link,
+    .in		= {
+      .argnr	= 2,
+      .extnr	= 0,
+      .handlers	= {
+		/* oldname */
+		{ .dual	= true, .blade = lemona_blade_string_null },
+		/* newname */
+		{ .dual	= true, .blade = lemona_blade_string_null },
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* retval */
+		{ .dual = false, .blade = lemona_blade_long },
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_unlink,
+    .in		= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* pathname */
+		{ .dual	= false, .blade = lemona_blade_string_null },
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* retval */
+		{ .dual = false, .blade = lemona_blade_long },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_execve,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_chdir,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_time,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mknod,
+    .in		= {
+      .argnr	= 3,
+      .extnr	= 0,
+      .handlers	= {
+		/* filename */
+		{ .dual	= true, .blade = lemona_blade_string_null },
+		/* mode */
+		{ .dual	= true, .blade = lemona_blade_integer },
+		/* dev */
+		{ .dual	= true, .blade = lemona_blade_long },
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* retval */
+		{ .dual = false, .blade = lemona_blade_long },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_chmod,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_lchown,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_break,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_oldstat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_lseek,
+    .in		= {
+      .argnr	= 3,
+      .extnr	= 0,
+      .handlers	= {
+	/* fd */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+	/* offset */
+	{ .dual	= false	, .blade = lemona_blade_long			},
+	/* whence */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+	/* ret */
+	{ .dual	= false	, .blade = lemona_blade_long			},
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getpid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mount,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_umount,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setuid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getuid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_stime,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ptrace,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_alarm,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_oldfstat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_pause,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_utime,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_stty,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_gtty,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_access,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_nice,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ftime,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sync,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_kill,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_rename,
+    .in		= {
+      .argnr	= 2,
+      .extnr	= 0,
+      .handlers	= {
+	/* oldname */
+	{ .dual	= true, .blade = lemona_blade_string_null },
+	/* newname */
+	{ .dual	= true, .blade = lemona_blade_string_null },
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+	/* retval */
+	{ .dual = false, .blade = lemona_blade_long },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mkdir,
+    .in		= {
+      .argnr	= 2,
+      .extnr	= 0,
+      .handlers	= {
+		/* path_name */
+		{ .dual	= false	, .blade = lemona_blade_string_null	},
+		/* mode */
+		{ .dual	= false	, .blade = lemona_blade_integer		}
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* retval */
+		{ .dual	= false	, .blade = lemona_blade_long	},
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_rmdir,
+    .in		= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* retval */
+		{ .dual	= false	, .blade = lemona_blade_string_null	},
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* retval */
+		{ .dual	= false	, .blade = lemona_blade_long	},
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_dup,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_pipe,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_times,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_prof,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_brk,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setgid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getgid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_signal,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_geteuid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getegid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_acct,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_umount2,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_lock,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ioctl,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fcntl,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mpx,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setpgid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ulimit,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_oldolduname,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_umask,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_chroot,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ustat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_dup2,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getppid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getpgrp,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setsid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sigaction,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sgetmask,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ssetmask,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setreuid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setregid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sigsuspend,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sigpending,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sethostname,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setrlimit,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getrlimit,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getrusage,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_gettimeofday,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_settimeofday,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getgroups,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setgroups,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_select,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_symlink,
+    .in		= {
+      .argnr	= 2,
+      .extnr	= 0,
+      .handlers	= {
+		/* oldname */
+		{ .dual	= false	, .blade = lemona_blade_string_null	},
+		/* newname */
+		{ .dual	= false	, .blade = lemona_blade_string_null	},
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* retval */
+		{ .dual	= false	, .blade = lemona_blade_long	},
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_oldlstat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_readlink,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_uselib,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_swapon,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_reboot,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_readdir,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mmap,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_munmap,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_truncate,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ftruncate,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fchmod,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fchown,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getpriority,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setpriority,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_profil,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_statfs,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fstatfs,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ioperm,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_socketcall,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_syslog,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setitimer,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getitimer,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_stat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_lstat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fstat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_olduname,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_iopl,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_vhangup,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_idle,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_vm86old,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_wait4,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_swapoff,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sysinfo,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ipc,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fsync,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sigreturn,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_clone,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setdomainname,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_uname,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_modify_ldt,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_adjtimex,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mprotect,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sigprocmask,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_create_module,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_init_module,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_delete_module,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_get_kernel_syms,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_quotactl,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getpgid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fchdir,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_bdflush,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sysfs,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_personality,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_afs_syscall,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setfsuid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setfsgid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR__llseek,
+    .in		= {
+      .argnr	= 4,
+      .extnr	= 0,
+      .handlers	= {
+	/* fd */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+	/* offset_hight */
+	{ .dual	= false	, .blade = lemona_blade_long			},
+	/* offset_low */
+	{ .dual	= false	, .blade = lemona_blade_long			},
+	/*
+	  We do not log the value of the incoming buffer 'result'.
+	*/
+	/* whence */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+	/*
+	  if < 0 the value will be an errno otherwise it is the value
+	  which has been stored in the user 'result' buffer.
+	*/
+	{ .dual = false	, .blade = lemona_blade_long_long		},
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getdents,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR__newselect,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_flock,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_msync,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_readv,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_writev,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getsid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fdatasync,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR__sysctl,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mlock,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_munlock,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mlockall,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_munlockall,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sched_setparam,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sched_getparam,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sched_setscheduler,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sched_getscheduler,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sched_yield,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sched_get_priority_max,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sched_get_priority_min,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sched_rr_get_interval,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_nanosleep,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mremap,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setresuid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getresuid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_vm86,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_query_module,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_poll,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_nfsservctl,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setresgid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getresgid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_prctl,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_rt_sigreturn,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_rt_sigaction,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_rt_sigprocmask,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_rt_sigpending,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_rt_sigtimedwait,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_rt_sigqueueinfo,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_rt_sigsuspend,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_pread64,
+    .in		= {
+      .argnr	= 3,
+      .extnr	= 0,
+      .handlers	= {
+	/* fd */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+
+	/* buf is logged on exit */
+
+	/* count */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+	/* offset */
+	{ .dual	= false	, .blade = lemona_blade_integer64		},
+      }
+    },
+    .out	= {
+      .argnr	= 2,
+      .extnr	= 0,
+      .handlers	= {
+	/* buf & ret (in this order) */
+	{ .dual	= true	, .blade = lemona_blade_output_buffer	},
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_pwrite64,
+    .in		= {
+      .argnr	= 4,
+      .extnr	= 0,
+      .handlers	= {
+	/* fd */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+	/* buf & count (in this order) */
+	{ .dual	= true	, .blade = lemona_blade_output_buffer	},
+	/* offset */
+	{ .dual	= false	, .blade = lemona_blade_integer64		},
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+	/* ret */
+	{ .dual = false	, .blade = lemona_blade_integer64	},
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_chown,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getcwd,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_capget,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_capset,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sigaltstack,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sendfile,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getpmsg,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_putpmsg,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_vfork,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ugetrlimit,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mmap2,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_truncate64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ftruncate64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_stat64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_lstat64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fstat64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_lchown32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getuid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getgid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_geteuid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getegid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setreuid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setregid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getgroups32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setgroups32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fchown32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setresuid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getresuid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setresgid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getresgid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_chown32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setuid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setgid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setfsuid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setfsgid32,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_pivot_root,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mincore,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_madvise, /* __NR_madvise1 as the same number */
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getdents64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fcntl64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+
+  /* 222 is unused in 2.6.26.3 */
+  {
+    .sysnr	= -1,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+
+  /* 223 is unused in 2.6.26.3 */
+  {
+    .sysnr	= -1,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+
+  {
+    .sysnr	= __NR_gettid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_readahead,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_setxattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_lsetxattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fsetxattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getxattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_lgetxattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fgetxattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_listxattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_llistxattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_flistxattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_removexattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_lremovexattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fremovexattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_tkill,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sendfile64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_futex,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sched_setaffinity,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sched_getaffinity,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_set_thread_area,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_get_thread_area,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_io_setup,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_io_destroy,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_io_getevents,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_io_submit,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_io_cancel,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fadvise64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+
+
+  /* 251 is unused in 2.6.26.3 */
+  {
+    .sysnr	= -1,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+
+  {
+    .sysnr	= __NR_exit_group,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_lookup_dcookie,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_epoll_create,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_epoll_ctl,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_epoll_wait,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_remap_file_pages,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_set_tid_address,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_timer_create,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_timer_settime,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_timer_gettime,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_timer_getoverrun,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_timer_delete,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_clock_settime,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_clock_gettime,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_clock_getres,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_clock_nanosleep,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_statfs64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fstatfs64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_tgkill,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_utimes,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fadvise64_64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_vserver,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mbind,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_get_mempolicy,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_set_mempolicy,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mq_open,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mq_unlink,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mq_timedsend,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mq_timedreceive,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mq_notify,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mq_getsetattr,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_kexec_load,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_waitid,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+
+  /*
+    for some reason __NR_sys_setaltroot is commented in 2.6.26.3
+    this should be syscall number 285
+  */
+  {
+    .sysnr	= -1,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+
+  {
+    .sysnr	= __NR_add_key,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_request_key,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_keyctl,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ioprio_set,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ioprio_get,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_inotify_init,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_inotify_add_watch,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_inotify_rm_watch,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_migrate_pages,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_openat,
+    .in		= {
+      .argnr	= 4,
+      .extnr	= 0,
+      .handlers	= {
+	/* dfd */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+	/* filename (user null terminated string) */
+	{ .dual	= false	, .blade = lemona_blade_string_null		},
+	/* flags */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+	/* mode */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 1,
+      .handlers	= {
+	/* ret */
+	{ .dual	= false	, .blade = lemona_blade_integer			},
+	/* get resolved path from fd (i.e. ret) */
+	{ .dual = false	, .blade = lemona_blade_string_fd		},
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mkdirat,
+    .in		= {
+      .argnr	= 3,
+      .extnr	= 0,
+      .handlers	= {
+		/* dfd */
+		{ .dual	= false, .blade = lemona_blade_integer },
+		/* pathname */
+		{ .dual	= false, .blade = lemona_blade_string_null },
+		/* mode */
+		{ .dual	= false, .blade = lemona_blade_integer },
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* retval */
+		{ .dual = false, .blade = lemona_blade_long },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_mknodat,
+    .in		= {
+      .argnr	= 4,
+      .extnr	= 0,
+      .handlers	= {
+		/* dfd */
+		{ .dual	= false, .blade = lemona_blade_integer },
+		/* filename */
+		{ .dual	= false, .blade = lemona_blade_string_null },
+		/* mode */
+		{ .dual	= false, .blade = lemona_blade_integer },
+		/* dev */
+		{ .dual	= false, .blade = lemona_blade_long },
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* retval */
+		{ .dual = false, .blade = lemona_blade_long },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fchownat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_futimesat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fstatat64,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_unlinkat,
+    .in		= {
+      .argnr	= 3,
+      .extnr	= 0,
+      .handlers	= {
+		/* dfd */
+		{ .dual = false, .blade = lemona_blade_integer },
+		/* pathname */
+		{ .dual = false, .blade = lemona_blade_string_null },
+		/* flag */
+		{ .dual = false, .blade = lemona_blade_integer },
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* retval */
+		{ .dual = false, .blade = lemona_blade_long },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_renameat,
+    .in		= {
+      .argnr	= 4,
+      .extnr	= 0,
+      .handlers	= {
+		/* olddfd */
+		{ .dual = false, .blade = lemona_blade_integer },
+		/* oldname */
+		{ .dual = false, .blade = lemona_blade_string_null },
+		/* newdfd */
+		{ .dual = false, .blade = lemona_blade_integer },
+		/*  */
+		{ .dual = false, .blade = lemona_blade_string_null },
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* error */
+		{ .dual = false, .blade = lemona_blade_long },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_linkat,
+    .in		= {
+      .argnr	= 5,
+      .extnr	= 0,
+      .handlers	= {
+		/* olddfd */
+		{ .dual = false, .blade = lemona_blade_integer },
+		/* oldname */
+		{ .dual = false, .blade = lemona_blade_string_null },
+		/* newdfd */
+		{ .dual = false, .blade = lemona_blade_integer },
+		/* newname */
+		{ .dual = false, .blade = lemona_blade_string_null },
+		/* flags */
+		{ .dual = false, .blade = lemona_blade_integer },
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* retval */
+		{ .dual = false, .blade = lemona_blade_long },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_symlinkat,
+    .in		= {
+      .argnr	= 3,
+      .extnr	= 0,
+      .handlers	= {
+		/* oldname */
+		{ .dual = false, .blade = lemona_blade_string_null },
+		/* newfd */
+		{ .dual = false, .blade = lemona_blade_integer },
+		/* newname */
+		{ .dual = false, .blade = lemona_blade_string_null },
+      }
+    },
+    .out	= {
+      .argnr	= 1,
+      .extnr	= 0,
+      .handlers	= {
+		/* retval */
+		{ .dual = false, .blade = lemona_blade_long },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_readlinkat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fchmodat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_faccessat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_pselect6,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_ppoll,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_unshare,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_set_robust_list,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_get_robust_list,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_splice,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_sync_file_range,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_tee,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_vmsplice,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_move_pages,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_getcpu,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_epoll_pwait,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_utimensat,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_signalfd,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_timerfd_create,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_eventfd,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_fallocate,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_timerfd_settime,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+  {
+    .sysnr	= __NR_timerfd_gettime,
+    .in		= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual	= true, .blade = NULL },
+      }
+    },
+    .out	= {
+      .argnr	= -1,
+      .extnr	= -1,
+      .handlers	= {
+	{ .dual = false, .blade = NULL },
+      },
+    }
+  },
+};
+
+const int	lemona_mixers_size = sizeof(lemona_mixers)
+					/ sizeof(*lemona_mixers);
+
diff -uNr linux.vanilla/lemona/net.c linux.lemona/lemona/net.c
--- linux.vanilla/lemona/net.c	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/net.c	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,141 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+#include <linux/jiffies.h> /* jiffies, time_after, HZ */
+#include <linux/module.h> /* module_param */
+
+#include "lemona.h"
+
+static char		*net_log_addr	= CONFIG_LEMONA_NET_LOG_SERV;
+static int		net_log_port	= CONFIG_LEMONA_NET_LOG_PORT;
+module_param(net_log_addr, charp, S_IRUGO);
+module_param(net_log_port, int, S_IRUGO);
+
+extern struct lemona	*juice;
+
+static void	__lemona_net_cleanup(void);
+
+static inline int	lemona_net_serv_get(void)
+{
+  u32			a, b, c, d;
+
+  if (sscanf(net_log_addr, "%u.%u.%u.%u", &a, &b, &c, &d) != 4)
+    return (-1);
+  if (a > 255 || b > 255 || c > 255 || d > 255)
+    return (-1);
+  return (htonl((a << 24) | (b << 16) | (c << 8) | d));
+}
+
+int				lemona_net_init(bool init)
+{
+  int		ret	= 0;
+  struct socket	*sock	= NULL;
+
+  if (init == true)
+    {
+      mutex_init(&(juice->net.lock));
+
+      juice->net.sin.sin_family		= AF_INET;
+      juice->net.sin.sin_addr.s_addr	= lemona_net_serv_get();
+      juice->net.sin.sin_port		= htons(net_log_port);
+    }
+
+  mutex_lock(&(juice->net.lock));
+
+  if (juice->net.sock != NULL
+      || (juice->net.sock == NULL
+	  && !(ret = time_after(jiffies, juice->net.timeout))
+	  && init == false))
+    goto out;
+
+  ret = sock_create_kern(AF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);
+  if (ret < 0)
+    {
+      lemona_printk("Unable to create new socket: %i\n", ret);
+      goto out;
+    }
+  juice->net.sock			= sock;
+
+  ret = kernel_connect(juice->net.sock,
+		       (struct sockaddr *)&(juice->net.sin),
+		       sizeof(juice->net.sin), 0);
+  if (ret < 0)
+    {
+      lemona_printk("Unable to connect to server: %i\n", ret);
+      goto out;
+    }
+  lemona_printk("We are now connected to server %s:%d\n",
+		net_log_addr, net_log_port);
+ out:
+  if (ret != 0)
+    {
+      juice->net.timeout	= jiffies + (NET_LOG_RETRY * HZ);
+      __lemona_net_cleanup();
+    }
+  mutex_unlock(&(juice->net.lock));
+  return (init ? 0 : ret);
+}
+
+/*
+ * This is simply a test to check how to send something on the network.
+ * Server IP/PORT should be given at module load time or during kernel config
+ */
+void			lemona_net_log(struct lemona_zest *zest)
+{
+  if (lemona_net_init(false) != 0)
+    return; /* couldn't get a socket working */
+
+  if (juice->net.sock)
+    {
+      int			ret;
+      int			sent;
+      struct kvec		kvec = {
+	.iov_base		= zest,
+	.iov_len		= zest->size
+      };
+      struct msghdr		hdr = { 0 };
+
+      hdr.msg_flags = MSG_NOSIGNAL;
+      mutex_lock(&(juice->net.lock));
+      for (sent = 0; sent != zest->size; sent += ret)
+	{
+	  ret = kernel_sendmsg(juice->net.sock, &hdr, &kvec, 1, kvec.iov_len);
+	  if (ret < 0)
+	    {
+	      lemona_printk("kernel_sendmsg: unable to send message: %i\n",
+			    ret);
+	      lemona_net_cleanup();
+	      /* this is the time after which we will be able to try again */
+	      juice->net.timeout	= jiffies + (NET_LOG_RETRY * HZ);
+	      break;
+	    }
+	}
+      mutex_unlock(&(juice->net.lock));
+    }
+}
+
+static void	__lemona_net_cleanup(void)
+{
+  if (!juice->net.sock)
+    return;
+  sock_release(juice->net.sock);
+  juice->net.sock	= NULL;
+}
+
+void	lemona_net_cleanup(void)
+{
+  mutex_lock(&(juice->net.lock));
+  __lemona_net_cleanup();
+  mutex_unlock(&(juice->net.lock));
+}
diff -uNr linux.vanilla/lemona/relay.c linux.lemona/lemona/relay.c
--- linux.vanilla/lemona/relay.c	1970-01-01 10:00:00.000000000 +1000
+++ linux.lemona/lemona/relay.c	2008-11-07 20:14:45.000000000 +1100
@@ -0,0 +1,159 @@
+/*
+** This file is part of Lemona.
+** Copyright (C) 2008 Kenfe-Mickaël Laventure
+**
+** The contents of this file are subject to the terms of either the
+** GNU General Public License Version 2 ("GPL") or the MIT License
+** (collectively, the "License"). You may not use this file except in
+** compliance with the License. You can obtain a copy of the License
+** at http://www.opensource.org/licenses/gpl-2.0.php and
+** http://www.opensource.org/licenses/mit-license.php or GPL.LICENSE
+** and MIT.LICENSE. See the License for the specific language
+** governing permissions and limitations under the License.
+*/
+
+#include <linux/module.h> /* module_param */
+
+#include "lemona.h"
+
+/*
+ * Lemona module's options
+ */
+static char		*debugfs_dir_name	= CONFIG_LEMONA_DEBUGFS_DIR;
+static int		relay_subbuf_sz		= CONFIG_LEMONA_RELAY_SBUF_SZ;
+static int		relay_subbuf_nr		= CONFIG_LEMONA_RELAY_SBUF_NR;
+module_param(debugfs_dir_name, charp, S_IRUGO);
+module_param(relay_subbuf_sz, int, S_IRUGO);
+module_param(relay_subbuf_nr, int, S_IRUGO);
+/***/
+
+extern struct lemona	*juice;
+
+/*
+ * For now, I've decided to put ourselves in no-overwrite mode. I
+ * frankly don't know which one to choose. Is it more important to
+ * have the following zest or the one already written? Hard choice,
+ * he?
+ */
+static int		lemona_relay_subbuf_start(struct rchan_buf *buf,
+						  void *subbuf,
+						  void *prev_subbuf,
+						  unsigned int prev_padding)
+{
+  if (relay_buf_full(buf))
+    return (0); /* TODO: some code to avoid creating zest if it's full */
+  return (1);
+}
+
+static struct dentry	*lemona_relay_create_buf_file(const char *filename,
+						      struct dentry *parent,
+						      int mode,
+						      struct rchan_buf *buf,
+						      int *is_global)
+{
+  struct dentry			*d;
+  struct lemona_relay_file	*f;
+
+  d = debugfs_create_file(filename, mode, parent,
+			  buf, &relay_file_operations);
+  if (d != NULL)
+    {
+      f = kmalloc(sizeof(*f), GFP_KERNEL);
+      if (f == NULL)
+	{
+	  debugfs_remove(d);
+	  d = NULL;
+	}
+      else
+	{
+	  f->d = d;
+	  list_add_tail(&(f->next), &(juice->relay.files));
+	}
+    }
+  return (d);
+}
+
+static int		lemona_relay_remove_buf_file(struct dentry *dentry)
+{
+  struct lemona_relay_file	*f;
+
+  list_for_each_entry(f, &(juice->relay.files), next) {
+    if (f->d == dentry)
+      {
+	list_del(&(f->next));
+	kfree(f);
+	break;
+      }
+  }
+  debugfs_remove(dentry);
+  return (0);
+}
+
+static struct rchan_callbacks	relay_callbacks = {
+  .subbuf_start		= lemona_relay_subbuf_start,
+  .create_buf_file	= lemona_relay_create_buf_file,
+  .remove_buf_file	= lemona_relay_remove_buf_file
+};
+
+int __init		lemona_relay_init(void)
+{
+  long			err = 0;
+
+  if (juice)
+    {
+      juice->dfs_dir = debugfs_create_dir(debugfs_dir_name, NULL);
+      if (juice->dfs_dir == NULL)
+	{
+	  lemona_printk("debugfs_create_dir: failed\n");
+	  err = IS_ERR(juice->dfs_dir) ? PTR_ERR(juice->dfs_dir) : -ENOMEM;
+	  goto err;
+	}
+      /*
+	need to be done before relay_open, since relay open will call
+	our lemona_relay_subbuf_start handler which use the list
+      */
+      INIT_LIST_HEAD(&(juice->relay.files));
+      juice->rchan = relay_open(LEMONA_RELAY_CHANNEL_NAME, juice->dfs_dir,
+				relay_subbuf_sz, relay_subbuf_nr,
+				&relay_callbacks, NULL);
+      if (juice->rchan == NULL)
+	{
+	  lemona_printk("relay_open: failed\n");
+	  err = IS_ERR(juice->rchan) ? PTR_ERR(juice->rchan) : -ENOMEM;
+	  goto err;
+	}
+    }
+  return (err);
+
+ err:
+  lemona_relay_cleanup();
+  return (err);
+}
+
+bool			lemona_relay_is_ours(const struct dentry *dentry)
+{
+  struct lemona_relay_file	*f;
+
+  list_for_each_entry(f, &(juice->relay.files), next) {
+    if (f->d == dentry)
+      return (true);
+  }
+  return (false);
+}
+
+int			lemona_relay_log(const struct lemona_zest *zest)
+{
+  relay_write(juice->rchan, zest, zest->size);
+  return (0);
+}
+
+void			lemona_relay_cleanup(void)
+{
+  if (juice)
+    {
+      if (juice->relay.chan)
+		relay_close(juice->relay.chan);
+      if (juice->relay.dir)
+		debugfs_remove(juice->relay.dir);
+    }
+}
diff -uNr linux.vanilla/mm/mmap.c linux.lemona/mm/mmap.c
--- linux.vanilla/mm/mmap.c	2008-08-21 04:11:37.000000000 +1000
+++ linux.lemona/mm/mmap.c	2008-11-05 20:12:50.000000000 +1100
@@ -1130,8 +1130,8 @@
 	 */
 	if (!file && !(vm_flags & VM_SHARED) &&
 	    vma_merge(mm, prev, addr, addr + len, vm_flags,
-					NULL, NULL, pgoff, NULL))
-		goto out;
+		      NULL, NULL, pgoff, NULL))
+	  goto out;
 
 	/*
 	 * Determine the object being mapped and call the appropriate
@@ -1218,6 +1218,7 @@
 	}
 	if ((flags & MAP_POPULATE) && !(flags & MAP_NONBLOCK))
 		make_pages_present(addr, addr + len);
+	/* LEMONA (mmap): save the vma addr here if file != NULL */
 	return addr;
 
 unmap_and_free_vma:
@@ -1785,6 +1786,7 @@
 		mm->map_count--;
 		tail_vma = vma;
 		vma = vma->vm_next;
+		/* LEMONA (unmap): we need to log read/written data */
 	} while (vma && vma->vm_start < end);
 	*insertion_point = vma;
 	tail_vma->vm_next = NULL;
